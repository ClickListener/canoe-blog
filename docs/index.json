[
    {
        "uri": "/post/2014-multi-university-training-contest-4",
        "title": "2014 Multi-University Training Contest 4",
        "content": "\r\n心情就像倒数第二楼那样。\r\n\r\nCLJ，我也保证不打死你……\r\n\r\nPS:最后一楼朱大神还暴露了。",
        "tags": []
    },
    {
        "uri": "/post/acm-international-collegiate-programming-contest-asia-regional-contest-tokyo-problem-d-space-golf",
        "title": "ACM International Collegiate Programming Contest Asia Regional Contest, Tokyo Problem D Space Golf",
        "content": "\r\n原题pdf：click here\r\nbr/\r\n\r\n- -\r\n\r\n日本的亚洲区域赛真心简单啊。两个小时就刷了5题有余了。排名第一的队伍才做出7道。\r\n\r\n题目真心长的可以了，看了半个小时才明白。。\r\n\r\n题意其实也就是太空中向前方抛小球，问小球能够穿过N个障碍物后到达制定地点的最小初始速度是多少。非常暴力的模拟题。离散化后直接枚举弹跳的次数再取最小值即可。注意45°方向能成功的话，那还是45°最优。\r\n!--more--\r\n`C++\r\nincludemap\r\nincludeset\r\nincludecmath\r\nincludestack\r\nincludequeue\r\nincludestring\r\nincludecstdio\r\nincludevector\r\nincludecctype\r\nincludecassert\r\nincludeutility\r\nincludenumeric\r\nincludecstring\r\nincludeiostream\r\nincludealgorithm\r\nusing namespace std;\r\ndefine pr pair\r\ndefine PR pairint,int\r\ndefine MP make_pair\r\ndefine SI(x) set::iterator\r\ndefine VI(x) vector::iterator\r\ndefine MI(x,y) mapx,y::iterator\r\ndefine SRI(x) set::reverse_iterator\r\ndefine VRI(x) vector::reverse_iterator\r\ndefine MRI(x,y) mapx,y::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine Sz(x) (int)x.size()\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clr(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u  1;\r\nconst LL lnf = ~0ull  1;\r\ndefine eps 1e-8\r\n/start/\r\nint d, n, b;\r\nPR ob[20];\r\nvectorpair<double, double  vt;\r\npairdouble, double dpr;\r\ndouble a2, e[2];\r\npairdouble, double Cramer(pairdouble, double dpr) {\r\n\tpairdouble, double res;\r\n\ta1 = dpr.F * dpr.F;\r\n\ta1 = dpr.F;\r\n\te[1] = dpr.S;\r\n\tdouble div = a0 * a1 - a1 * a0;\r\n\tres.F = (e0] * a[1 - e1] * a[0) / div;\r\n\tres.S = (e1] * a[0 - e0] * a[1) / div;\r\n\treturn res;\r\n}\r\nint main(int argc, char **argv) {\r\n\twhile (~scanf(\"%d%d%d\", &amp;d, &amp;n, &amp;b)) {\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tscanf(\"%d%d\", &amp;ob[i].F, &amp;ob[i].S);\r\n\t\t}\r\n\t\tdouble ans = inf;\r\n\t\tfor (int c = 0; c <= b; c++) {//enumerate the times bullet bounces the surface\r\n\t\t\tdouble dist = 1.0 * d / (c + 1);\r\n\t\t\tint f = 1;\r\n\t\t\ta0 = dist * dist;\r\n\t\t\ta0 = dist;\r\n\t\t\te[0] = 0;\r\n\t\t\tvt.clear();\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\tdpr = ob[i];\r\n\t\t\t\twhile (dpr.F + eps = dist) {\r\n\t\t\t\t\tdpr.F -= dist;\r\n\t\t\t\t}\r\n\t\t\t\tif (dpr.F <= eps) {\r\n\t\t\t\t\tf = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tvt.push_back(dpr);\r\n\t\t\t}\r\n\t\t\tif (f == 0) continue;\r\n\t\t\tpairdouble, double res;   \r\n\t\t\tfor (int i = 0; i < Sz(vt); i++) {\r\n\t\t\t\tdpr = vt[i];\r\n\t\t\t\tif (i == 0) {\r\n\t\t\t\t\tres = Cramer(dpr);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdouble tmph = dpr.F * dpr.F * res.F + dpr.F * res.S;\r\n\t\t\t\t\tif (tmph + eps < dpr.S) {\r\n\t\t\t\t\t\tres = Cramer(dpr);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tres.F = -1.0 / (2 * res.F);\r\n\t\t\tres.S = res.F * res.S * res.S;\r\n\t\t\tans = min(ans, sqrt(res.F + res.S));\r\n                        //if the vector's angle is less than 45\r\n\t\t\tif (res.S + eps < res.F) ans = min(ans, sqrt(dist));\r\n\t\t}\r\n\t\tprintf(\"%.5f\\n\", ans);\r\n\t}\r\n}\r\n`\r\n",
        "tags": []
    },
    {
        "uri": "/post/ASP-NET-MVC4-note1-Simplemembership",
        "title": "ASP.NET MVC4笔记（一） 扩展Simplemembership",
        "content": "\r\n`C#\r\nusing System.Web.Mvc;\r\n\r\nnamespace MvcClassManageSystem.ActionFilters\r\n{\r\n    public class LogStateFilterAttribute : ActionFilterAttribute\r\n    {\r\n        public override void OnActionExecuting(ActionExecutingContext filterContext)\r\n        {\r\n            base.OnActionExecuting(filterContext);\r\n            //string controller = filterContext.RouteData.Values[\"controller\"].ToString();\r\n            //string action = filterContext.RouteData.Values[\"action\"].ToString();\r\n            //System.Diagnostics.Debug.WriteLine(\"OnAction:\" + controller + \"/\" + action);\r\n\r\n            if (WebMatrix.WebData.WebSecurity.IsAuthenticated == true)\r\n            {\r\n                filterContext.Result = new RedirectToRouteResult(new System.Web.Routing.RouteValueDictionary(new { Controller = \"Home\", action = \"Index\" }));\r\n            }\r\n        }\r\n    }\r\n}\r\n`\r\n!--more--\r\n`C#\r\npublic static class WebUtility\r\n    {\r\n        private static SimpleMembershipProvider membership = (SimpleMembershipProvider)Membership.Provider;\r\n        public static void CreateUserAndAccount(UserProfile userProfile, string Password)\r\n        {\r\n            WebSecurity.CreateUserAndAccount(userProfile.UserName, Password, new\r\n            {\r\n                //TO DO 数据库/模型更改之后别忘记修改此处！！！\r\n                ClassId = userProfile.ClassId,\r\n                UserExtraInfo_Phone = userProfile.UserExtraInfo.Phone,\r\n                UserExtraInfo_Gender = userProfile.UserExtraInfo.Gender,\r\n                UserExtraInfo_BirthDay = userProfile.UserExtraInfo.BirthDay,\r\n                UserExtraInfo_UserDesc = userProfile.UserExtraInfo.UserDesc\r\n            });\r\n        }\r\n        public static void DeleteUserAndAccount(string UserName)\r\n        {\r\n            membership.DeleteAccount(UserName);\r\n            Roles.RemoveUserFromRoles(UserName, Roles.GetRolesForUser(UserName));\r\n            membership.DeleteUser(UserName, true);\r\n        }\r\n        public static void ResetPassword(string UserName, string NewPassword)\r\n        {\r\n            WebSecurity.ResetPassword(WebSecurity.GeneratePasswordResetToken(UserName, 1), NewPassword);\r\n        }\r\n    }\r\n`\r\n\r\n`C#\r\nusing System.Web.Mvc;\r\nnamespace MvcClassManageSystem.Filters\r\n{\r\n    public class MyAuthorizeAttribute : AuthorizeAttribute\r\n    {\r\n        protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext)\r\n        {\r\n            base.HandleUnauthorizedRequest(filterContext);\r\n            if (filterContext.HttpContext.User.Identity.IsAuthenticated)\r\n            {\r\n                filterContext.Result = new RedirectResult(\"/Account/AccessError\");\r\n            }\r\n        }\r\n    }\r\n}\r\n`\r\n\r\n`C#\r\nusing System.Data.Entity;\r\nusing System.Linq;\r\nusing System.Web.Security;\r\nusing WebMatrix.WebData;\r\nnamespace MvcClassManageSystem.Models\r\n{\r\n    public class InitSecurityDb : DropCreateDatabaseAlwaysDBManager\r\n    {\r\n        protected override void Seed(DBManager context)\r\n        {\r\n            WebSecurity.InitializeDatabaseConnection(\"DefaultConnection\", \"UserProfile\", \"UserId\", \"UserName\", autoCreateTables: true);\r\n            var roles = (SimpleRoleProvider)Roles.Provider;\r\n \r\n            string[] RolesList = new string[] { \"Admin\", \"Teacher\", \"Student\" };\r\n            foreach (var item in RolesList)\r\n            {\r\n                if (!roles.RoleExists(item))\r\n                {\r\n                    roles.CreateRole(item);\r\n                }\r\n            }\r\n            //设置初始班级\r\n            int ClassIndex = 0;\r\n            using (var db = new DBManager())\r\n            {\r\n                var ret = db.ClassProfiles.SingleOrDefault(m = m.ClassName.CompareTo(\"未知班级\") == 0);\r\n                if (ret == null)\r\n                {\r\n                    ret = db.ClassProfiles.Add(new ClassProfile\r\n                    {\r\n                        ClassName = \"未知班级\",\r\n                        Desc = \"班级未知或无意义\"\r\n                    });\r\n                    db.SaveChanges();\r\n                }\r\n                ClassIndex = ret.ClassId;\r\n            }\r\n            if (!WebSecurity.UserExists(\"管理员\"))\r\n            {\r\n                WebUtility.CreateUserAndAccount(new UserProfile()\r\n                {\r\n                    UserName = \"管理员\",\r\n                    ClassId = ClassIndex,\r\n                    UserExtraInfo = new UserExtraInfo()\r\n                    {\r\n                        Phone = \"18267912632\",\r\n                        Gender = MvcClassManageSystem.Models.Gender.男,\r\n                        BirthDay = new System.DateTime(1993, 9, 28),\r\n                        UserDesc = \"本站的管理员！\"\r\n                    }\r\n                }, \"admin\");\r\n                System.Web.Security.Roles.AddUserToRole(\"管理员\", \"Admin\");\r\n            }\r\n        }\r\n    }\r\n}\r\n`\r\n`C#\r\n protected void Application_Start()\r\n        {\r\n            Database.SetInitializerDBManager(new InitSecurityDb());\r\n            DBManager db = new DBManager();\r\n            db.Database.Initialize(true);\r\n            if (!WebSecurity.Initialized)\r\n            {\r\n                WebSecurity.InitializeDatabaseConnection(\"DefaultConnection\", \"UserProfile\", \"UserId\", \"UserName\", autoCreateTables: true);\r\n            }\r\n\r\n            AreaRegistration.RegisterAllAreas();\r\n            WebApiConfig.Register(GlobalConfiguration.Configuration);\r\n            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);\r\n            RouteConfig.RegisterRoutes(RouteTable.Routes);\r\n            BundleConfig.RegisterBundles(BundleTable.Bundles);\r\n            AuthConfig.RegisterAuth();\r\n        }\r\n`",
        "tags": []
    },
    {
        "uri": "/post/ASP-NET-MVC4note2",
        "title": "ASP.NET MVC 4笔记（二）",
        "content": "\r\n有Timestamp修饰的表在修改已有的记录是一定要将该字段复制，也就是说一定要在Edit网页里面添加一行：\r\n\t\t@Html.HiddenFor(model = model.RowVersion)\r\nWebSecurity.CreateAccount必须在Userprofile里面先创建账户。\r\n\t\tSystem.Diagnostics.Debug.WriteLine(\"OnAction:\" + controller + \"/\" + action);\r\n转换string数组到int数组\r\n\t\tint[] HostsList = Array.ConvertAllstring, int(Request[\"HostsId\"].Split(','), u = int.Parse(u));",
        "tags": [
            "C#",
            "asp.net mvc4"
        ]
    },
    {
        "uri": "/post/baylor6622-absurdistan-roads",
        "title": "baylor 6622 Absurdistan Roads（ NWERC Contest）",
        "content": "\r\n\r\n原题pdf：click here\r\n\r\nDescription\r\nThe people of Absurdistan discovered how to build roads only last year. After the discovery, every city\r\ndecided to build their own road connecting their city with another city. Each newly built road can be\r\nused in both directions.\r\n\r\nAbsurdistan is full of surprising coincidences. It took all N cities precisely one year to build their\r\nroads. And even more surprisingly, in the end it was possible to travel from every city to every other\r\ncity using the newly built roads.\r\n\r\n!--more--\r\nYou bought a tourist guide which does not have a map of the country with the new roads. It only\r\ncontains a huge table with the shortest distances between all pairs of cities using the newly built roads.\r\n\r\nYou would like to know between which pairs of cities there are roads and how long they are, because\r\nyou want to reconstruct the map of the N newly built roads from the table of shortest distances.\r\n\r\nYou get a table of shortest distances between all pairs of cities in Absurdistan using the N roads\r\nbuilt last year. From this table, you must reconstruct the road network of Absurdistan. There might\r\nbe multiple road networks with N roads with that same table of shortest distances, but you are happy\r\nwith any one of those networks.\r\n\r\n Input\r\nFor each test case:  \r\n\r\n• A line containing an integer N (2 ≤ N ≤ 2000) — the number of cities and roads.  \r\n\r\n• N lines with N numbers each. The j-th number of the i-th line is the shortest distance from city i to city j.\r\n\r\n• All distances between two distinct cities will be positive and at most 1 000 000. The\r\ndistance from i to i will always be 0 and the distance from i to j will be the same as the distance\r\nfrom j to i.\r\n\r\nOutput\r\nFor each test case:\r\n\r\n• Print N lines with three integers ‘a b c’ denoting that there is a road between cities 1 ≤ a ≤ N\r\nand 1 ≤ b ≤ N of length 1 ≤ c ≤ 1000000, where a ̸= b. If there are multiple solutions, you can\r\nprint any one and you can print the roads in any order. At least one solution is guaranteed to\r\nexist.\r\n\r\n• Print a blank line between every two test cases.\r\n Sample Input\r\n`\r\n4  \r\n0 1 2 1  \r\n1 0 2 1  \r\n2 2 0 1  \r\n1 1 1 0  \r\n4  \r\n0 1 1 1  \r\n1 0 2 2  \r\n1 2 0 2  \r\n1 2 2 0  \r\n3  \r\n0 4 1  \r\n4 0 3  \r\n1 3 0\r\n`  \r\nSample Output\r\n`\r\n2 1 1  \r\n4 1 1  \r\n4 2 1  \r\n4 3 1  \r\n2 1 1  \r\n3 1 1  \r\n4 1 1  \r\n2 1 1  \r\n3 1 1  \r\n2 1 4  \r\n3 2 3  \r\n- -\r\n`\r\n\r\nNWERC 题目还挺简单的。  \r\n题意就是一个N个顶点，N条边的无向图。告诉你两两点之间的最短路。让你重构这个图。(随意输出任意一张满足以上条件的图）  \r\n这题的突破口就是N条边。要想想如果只有N-1条边，那么这个图就是一个树了。所以，我们可以先构造最小生成树，再来考虑最后一条边。  \r\n可以先将构造好的树求一遍floyd，然后再跟题目的最短路相比较，如果两点u,v求出的最短路w\\与题目给的最短路w不一致（可以断言：w\\&gt;w），那么就将w作为最后一条边的边长加在u，v之间即可。这样的边可能会找到很多，事实上只需要加上任意一条就使所有的w\\`都等于w了。\r\n需要注意的是，可能整个树就已经满足题目了。这样的话，最后一条边只需要重复任意一条树边就好了。\r\n\r\n`C++\r\nincludeiostream\r\nincludecstdio\r\nincludecstring\r\nincludevector\r\nincludealgorithm\r\nusing namespace std;\r\nconst int N = 2010;\r\nconst int inf = 1 << 25;\r\nint p[N];\r\nint ufind(int x) {\r\n\treturn x == p[x] ? x : p[x] = ufind(p[x]);\r\n}\r\nbool Union(int x, int y) {\r\n\tint fx = ufind(x);\r\n\tint fy = ufind(y);\r\n\tif (fx == fy)\r\n\t\treturn false;\r\n\tp[fx] = fy;\r\n\treturn true;\r\n}\r\nint n;\r\nstruct Edge {\r\n\tint u, v, w;\r\n\tEdge(int u = 0, int v = 0, int w = 0) :\r\n\t\t\tu(u), v(v), w(w) {\r\n\t}\r\n\tbool operator<(const Edge& othr) const {\r\n\t\treturn w < othr.w;\r\n\t}\r\n};\r\nvectorEdge vt;\r\nvectorEdge res;\r\nint fN;\r\nint main() {\r\n\tbool first = true;\r\n\twhile (~scanf(\"%d\", &n)) {\r\n\t\tvt.clear();\r\n\t\tres.clear();\r\n\t\tif (!first) printf(\"\\n\");\r\n\t\telse first = false;\r\n\t\tfor (int i = 1; i <= n; i++) {\r\n\t\t\tfor (int x, j = 1; j <= n; j++) {\r\n\t\t\t\tscanf(\"%d\", &x);\r\n\t\t\t\tif (j  i)\r\n\t\t\t\t\tvt.push_back(Edge(i, j, x));\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i = 0; i <= n; i++) p[i] = i;\r\n\t\tsort(vt.begin(), vt.end());\r\n\t\tfor(int i=1;i<=n;i++) fill(f[i]+1,f[i]+1+n,inf);\r\n\t\tfor (int cnt = 0, i = 0; i < (int) vt.size(); i++) {\r\n\t\t\tif (Union(vt[i].u, vt[i].v)) {\r\n\t\t\t\tfvt[i].u.v] = vt[i].w;\r\n\t\t\t\tfvt[i].v.u] = vt[i].w;\r\n\t\t\t\tcnt++;\r\n\t\t\t\tres.push_back(Edge(vt[i].u, vt[i].v, vt[i].w));\r\n\t\t\t\tif (cnt = n - 1) break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (int k = 1; k <= n; k++) {\r\n\t\t\tfor (int i = 1; i <= n; i++) {\r\n\t\t\t\tfor (int j = 1; j <= n; j++) {\r\n\t\t\t\t\tif (fi == inf) break;\r\n\t\t\t\t\tif (fi  fi + fk) {\r\n\t\t\t\t\t\tfi = fi + fk;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tint flag = true;\r\n\t\tfor (int i = 0; i < (int) vt.size(); i++) {\r\n\t\t\tEdge now = vt[i];\r\n\t\t\tif (fnow.u != now.w) {\r\n\t\t\t\tres.push_back(Edge(now.u, now.v, now.w));\r\n\t\t\t\tflag = false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (flag) res.push_back(res.back());\r\n\t\tfor (int i = 0; i < (int) res.size(); i++) {\r\n\t\t\tprintf(\"%d %d %d\\n\", res[i].u, res[i].v, res[i].w);\r\n\t\t}\r\n\t}\r\n}\r\n`",
        "tags": []
    },
    {
        "uri": "/post/fft-thoughts",
        "title": "FFT求快速卷积的思考",
        "content": "\r\n\r\n离散型卷积的定义是：$$y(n)=\\sum_{m=0}^{n} x(m)h(n-m)$$\r\n\r\n注意，h函数是反转的。\r\n\r\n在Chipher Messages一题中，b串需要反转再与a串匹配。\r\n\r\n比如说：\r\n\r\na串： 110110110，则：\r\n\r\nb\\`串：1011&lt;",
        "tags": []
    },
    {
        "uri": "/post/hdu-2874-connections-between-cities",
        "title": "HDU 2874 Connections between cities",
        "content": "\r\n\r\nConnections between cities\r\n\r\n**span style=\"font-family: Arial; font-size: 12px; font-weight: bold; color: green;\"Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)\r\nTotal Submission(s): 4759    Accepted Submission(s): 1341\r\n/span**\r\ndiv class=\"panel_title\" align=\"left\"Problem Description/div\r\ndiv class=\"panel_content\"After World War X, a lot of cities have been seriously damaged, and we need to rebuild those cities. However, some materials needed can only be produced in certain places. So we need to transport these materials from city to city. For most of roads had been totally destroyed during the war, there might be no path between two cities, no circle exists as well.\r\nNow, your task comes. After giving you the condition of the roads, we want to know if there exists a path between any two cities. If the answer is yes, output the shortest path between them./div\r\n!--more--\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Input/div\r\ndiv class=\"panel_content\"Input consists of multiple problem instances.For each instance, first line contains three integers n, m and c, 2&lt;=n&lt;=10000, 0&lt;=m&lt;10000, 1&lt;=c&lt;=1000000\\. n represents the number of cities numbered from 1 to n. Following m lines, each line has three integers i, j and k, represent a road between city i and city j, with length k. Last c lines, two integers i, j each line, indicates a query of city i and city j./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Output/div\r\ndiv class=\"panel_content\"For each problem instance, one line for each query. If no path between two cities, output “Not connected”, otherwise output the length of the shortest path between them./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Input/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"5 3 2 1 3 2 2 4 3 5 2 3 1 4 4 5/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Output/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"Not connected 6\r\ndiv style=\"font-family: Times New Roman; font-size: 14px; background-color: f4fbff; border: B7CBFF 1px dashed; padding: 6px;\"\r\ndiv style=\"font-family: Arial; font-weight: bold; color: #7ca9ed; border-bottom: #B7CBFF 1px dashed;\"Hint/div\r\nHint Huge input, scanf recommended./div\r\n_ _/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Source/div\r\ndiv class=\"panel_content\" 2009 Multi-University Training Contest 8 - Host by BJNU /div\r\n\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;cmath&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine PR pair&lt;int,int&gt;\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine Sz(x) (int)x.size()\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clr(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\n/start/\r\ndefine N 10004\r\ndefine M 10005\r\nint n, m, c;\r\nstruct Edge {\r\n    int v, w, nxt;\r\n} e[M &lt;&lt; 1];\r\nint head[N], ecnt;\r\nvoid initEdge() {\r\n    memset(head, -1, sizeof(head));\r\n    ecnt = 0;\r\n}\r\nvoid add(int u, int v, int w) {\r\n    e[ecnt].v = v;\r\n    e[ecnt].w = w;\r\n    e[ecnt].nxt = head[u];\r\n    head[u] = ecnt++;\r\n}\r\n//RMQ\r\nint dpM20;\r\nint lg2[N &lt;&lt; 1];\r\ndefine getL(R,L) (R-(L)+1)\r\nvoid initRMQ(int n) {\r\n    lg2[0] = -1;\r\n    int m;\r\n    for (int i = 1; i &lt;= n; i++)\r\n        lg2[i] = i &amp; (i - 1) ? lg2[i - 1] : lg2[i - 1] + 1;\r\n    for (int i = 1; i &lt;= lg2[n]; i++) {\r\n        m = getL(n, 1 &lt;&lt; i);\r\n        for (int j = 1; j &lt;= m; j++) {\r\n            dpMi = min(dpMi - 1, dpMi - 1)]);\r\n        }\r\n    }\r\n}\r\nint getRMQ(int a, int b) {\r\n    if (a &gt; b) swap(a, b);\r\n    int s = lg2[b - a + 1];\r\n    return min(dpMs, dpMs]);\r\n}\r\n//LCA\r\nint E[N];\r\nint T[N];\r\nint H[N];\r\nint depth, cnt;\r\nint belong[N], bcnt;\r\nint findRoot() {\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        if (belong[i] == 0) return i;\r\n    }\r\n    return -1;\r\n}\r\nvoid getEuler(int u, int fa = -1) {\r\n    int tmp = dpM0 = ++cnt] = ++depth;\r\n    E[tmp] = u;\r\n    belong[u] = bcnt;\r\n    for (int i = head[u]; ~i; i = e[i].nxt) {\r\n        int v = e[i].v;\r\n        if (v == fa) continue;\r\n        T[v] = T[u] + e[i].w;\r\n        getEuler(v, u);\r\n        dpM0 = tmp;\r\n    }\r\n}\r\nvoid initLCA() {\r\n\r\n    memset(T, 0, sizeof(T));\r\n    memset(belong, 0, sizeof(belong));\r\n    bcnt = cnt = depth = 0;\r\n    int root;\r\n    while ((root = findRoot()) != -1) {\r\n        ++bcnt;\r\n        getEuler(root);\r\n    }\r\n    initRMQ(cnt);\r\n}\r\nint getLCA(int u, int v) {\r\n    if (belong[u] != belong[v]) return -1;\r\n    if (H[u] &gt; H[v]) swap(u, v);\r\n    return E[getRMQ(H[u], H[v])];\r\n}\r\nint main(int argc, char **argv) {\r\n    while (~scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c)) {\r\n        initEdge();\r\n        int u, v, w;\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);\r\n            add(u, v, w);\r\n            add(v, u, w);\r\n        }\r\n        initLCA();\r\n        while (c--) {\r\n            scanf(\"%d%d\", &amp;u, &amp;v);\r\n            int r = getLCA(u, v);\r\n            if (r == -1) puts(\"Not connected\");\r\n            else {\r\n                printf(\"%d\\n\", T[u] + T[v] - 2 * T[r]);\r\n            }\r\n        }\r\n    }\r\n}\r\n`\r\n\r\n/pre",
        "tags": []
    },
    {
        "uri": "/post/hdu-4945-2048",
        "title": "HDU 4945 2048",
        "content": "\r\n\r\n**span style=\"font-family: Arial; font-size: 12px; font-weight: bold; color: green;\"Time Limit: 3000/1500 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)\r\nTotal Submission(s): 590    Accepted Submission(s): 136\r\n/span**\r\ndiv class=\"panel_title\" align=\"left\"Problem Description/div\r\ndiv class=\"panel_content\"\r\n\r\nTeacher Mai is addicted to game 2048\\. But finally he finds it's too hard to get 2048\\. So he wants to change the rule:\r\n\r\nYou are given some numbers. Every time you can choose two numbers of the same value from them and merge these two numbers into their sum. And these two numbers disappear meanwhile.\r\n\r\nIf we can get 2048 from a set of numbers with this operation, Teacher Mai think this multiset is good.\r\n\r\nYou have n numbers, Asub1/sub,...,Asubn/sub. Teacher Mai ask you how many subsequences of A are good.\r\n\r\nThe number can be very large, just output the number modulo 998244353.\r\n!--more--\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Input/div\r\ndiv class=\"panel_content\"\r\n\r\nThere are multiple test cases, terminated by a line \"0\".\r\n\r\nFor each test case, the first line contains an integer n (1&lt;=n&lt;=10^5), the next line contains n integers asubi/sub (0&lt;=asubi/sub&lt;=2048).\r\n\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Output/div\r\ndiv class=\"panel_content\"For each test case, output one line \"Case #k: ans\", where k is the case number counting from 1, ans is the number module 998244353./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Input/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"4 1024 512 256 256 4 1024 1024 1024 1024 5 1024 512 512 512 1 0/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Output/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"\r\n\r\nCase #1: 1 Case #2: 11 Case #3: 8\r\ndiv style=\"font-family: Times New Roman; font-size: 14px; background-color: f4fbff; border: #B7CBFF 1px dashed; padding: 6px;\"\r\ndiv style=\"font-family: Arial; font-weight: bold; color: #7ca9ed; border-bottom: #B7CBFF 1px dashed;\"Hint/div\r\nIn the first case, we should choose all the numbers. In the second case, all the subsequences which contain more than one number are good.\r\n\r\n/div\r\n&nbsp;\r\n\r\n/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Source/div\r\ndiv class=\"panel_content\" 2014 Multi-University Training Contest 8 /div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Recommend/div\r\ndiv class=\"panel_content\"hujie   |   We have carefully selected several similar problems for you:  4955 4954 4953 4952 4951/div\r\nbr/\r\n- -\r\n\r\n\r\ndiv class=\"panel_content\"貌似这几天第一次做的DP题啊。想象一下二进制就能明白——当子序列的2次幂数字之和大于等于2048时这个序列就是good序列了。正面dp要dp出2048~100000肯定要超时，而反面dp只需要dp出0~2047就够了。复杂度大大降低O（11＊2048*2048）。/div\r\ndiv class=\"panel_content\"标程写的很厉害！尤其是逆元的处理！/div\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;cmath&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine PR pair&lt;int,int&gt;\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine Sz(x) (int)x.size()\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clr(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\n/start/\r\ndefine MOD 998244353\r\nint cnt[3010];\r\nLL f[101000], g[101000];\r\nint pn, n, __;\r\nint dp13; //表示取了2^0、2^1、2^2、……、2^i种元素，总和加起来等于j*2^(i+1)的所有情况\r\ninline int getint() {\r\n    int ret = 0;\r\n    bool ok = 0;\r\n    for (;;) {\r\n        int c = getchar();\r\n        if (c &gt;= '0' &amp;&amp; c &lt;= '9') ret = (ret &lt;&lt; 3) + ret + ret + c - '0', ok = 1;\r\n        else if (ok) return ret;\r\n    }\r\n}\r\ninline LL powmod(LL b, int x) {\r\n    LL res = 1;\r\n    for (b %= MOD; x; x &gt;&gt;= 1) {\r\n        if (x &amp; 1) res = res * b % MOD;\r\n        b = b * b % MOD;\r\n    }\r\n    return res;\r\n}\r\nint main(int argc, char **argv) {\r\n    f[0] = 1;\r\n    for (int i = 1; i &lt;= 100000; i++)\r\n        f[i] = f[i - 1] * i % MOD;\r\n    g[100000] = powmod(f[100000], MOD - 2);\r\n    for (int i = 99999; i &gt;= 0; i--)\r\n        g[i] = g[i + 1] * (i + 1) % MOD;\r\n\r\n    while (1) {\r\n        n = getint();\r\n        if (n == 0) break;\r\n        for (int k = 1; k &lt;= 2048; k &lt;&lt;= 1)\r\n            cnt[k] = 0;\r\n        for (int i = 0; i &lt; n; i++) {\r\n            cnt[getint()]++;\r\n        }\r\n        pn = 0;\r\n        for (int k = 1; k &lt;= 2048; k &lt;&lt;= 1)\r\n            pn += cnt[k];\r\n        for (int i = 0, m = 1024; i &lt;= 11; i++, m &gt;&gt;= 1) {\r\n            for (int j = 0; j &lt;= m; j++) {\r\n                dpi = 0;\r\n            }\r\n        }\r\n        int ct = cnt[1];\r\n        LL cof = f[ct];\r\n        for (int i = 0; i &lt;= ct &amp;&amp; i &lt; 2048; i++) {\r\n            dp0 += g[ct - i] * g[i] % MOD;\r\n            if (dp0 &gt; MOD) dp0 -= MOD;\r\n        }\r\n\r\n        for (int i = 1, m = 1024; i &lt;= 11; i++, m &gt;&gt;= 1) {\r\n            ct = cnt[1 &lt;&lt; i];\r\n            cof = cof * f[ct] % MOD;\r\n            for (int j = 0; j &lt; m; j++) { \r\n                if (dpi - 1) {\r\n                    for (int k = 0; k &lt;= ct &amp;&amp; j + k &lt; m; k++) {//不要把满足good的序列转移上去。\r\n                        dpi &gt;&gt; 1] += dpi - 1 * g[k] % MOD * g[ct - k] % MOD;\r\n                        if (dpi &gt;&gt; 1] &gt; MOD) dpi &gt;&gt; 1] -= MOD;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        int ans = (powmod(2, pn) - dp11 * cof) % MOD\r\n                powmod(2, n - pn)%MOD;\r\n        if (ans &lt; 0) ans += MOD;\r\n        printf(\"Case %d: %d\\n\", ++__, ans);\r\n    }\r\n}\r\n`",
        "tags": []
    },
    {
        "uri": "/post/hdu-4952-number-transformation",
        "title": "HDU 4952 Number Transformation",
        "content": "\r\n\r\n**span style=\"font-family: Arial; font-size: 12px; font-weight: bold; color: green;\"Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)\r\nTotal Submission(s): 612    Accepted Submission(s): 310\r\n/span**\r\ndiv class=\"panel_title\" align=\"left\"Problem Description/div\r\ndiv class=\"panel_content\"Teacher Mai has an integer x.\r\n\r\nHe does the following operations k times. In the i-th operation, x becomes the least integer no less than x, which is the multiple of i.\r\n\r\nHe wants to know what is the number x now./div\r\ndiv class=\"panel_bottom\"/div\r\n!--more--\r\n&nbsp;\r\n\r\ndiv class=\"panel_title\" align=\"left\"Input/div\r\ndiv class=\"panel_content\"There are multiple test cases, terminated by a line \"0 0\".\r\n\r\nFor each test case, the only one line contains two integers x,k(1&lt;=x&lt;=10^10, 1&lt;=k&lt;=10^10)./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Output/div\r\ndiv class=\"panel_content\"For each test case, output one line \"Case #k: x\", where k is the case number counting from 1./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Input/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"2520 10 2520 20 0 0/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Output/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"Case #1: 2520 Case #2: 2600/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Source/div\r\ndiv class=\"panel_content\" 2014 Multi-University Training Contest 8 /div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Recommend/div\r\ndiv class=\"panel_content\"hujie   |   We have carefully selected several similar problems for you:  4955 4954 4953 4951 4950/div\r\nbr/\r\n\r\n- -\r\n\r\n\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;cmath&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine PR pair&lt;int,int&gt;\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine Sz(x) (int)x.size()\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clr(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\n/start/\r\nint __;\r\ndefine type LL\r\ninline type getint() {\r\n    type ret=0;bool ok=0;\r\n    for(;;) {\r\n        int c=getchar();\r\n        if(c&gt;='0'&amp;&amp;c&lt;='9')ret=(ret&lt;&lt;3)+ret+ret+c-'0',ok=1;\r\n        else if(ok)return ret;\r\n    }\r\n}\r\nundef type\r\nint main(int argc, char **argv) {\r\n    LL x, k;\r\n    while (1) {\r\n        x=getint();\r\n        k=getint();\r\n        if (x == 0 &amp;&amp; k == 0) break;\r\n        for(int i=1;i&lt;k;i++){\r\n            if(x&lt;i+1)break;\r\n            x-=x/(i+1);\r\n        }\r\n        printf(\"Case #%d: \"LLS\"\\n\",++__,x*k);\r\n    }\r\n}\r\n`",
        "tags": []
    },
    {
        "uri": "/post/hdu-4965-fast-matrix-calculation",
        "title": "HDU 4965 Fast Matrix Calculation",
        "content": "\r\n**span style=\"font-family: Arial; font-size: 12px; font-weight: bold; color: green;\"Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 131072/131072 K (Java/Others)\r\nTotal Submission(s): 206    Accepted Submission(s): 116\r\n/span**\r\ndiv class=\"panel_title\" align=\"left\"Problem Description/div\r\ndiv class=\"panel_content\"\r\n\r\nOne day, Alice and Bob felt bored again, Bob knows Alice is a girl who loves math and is just learning something about matrix, so he decided to make a crazy problem for her.\r\n\r\nBob has a six-faced dice which has numbers 0, 1, 2, 3, 4 and 5 on each face. At first, he will choose a number N (4 &lt;= N &lt;= 1000), and for N times, he keeps throwing his dice for K times (2 &lt;=K &lt;= 6) and writes down its number on the top face to make an NK matrix A, in which each element is not less than 0 and not greater than 5\\. Then he does similar thing again with a bit difference: he keeps throwing his dice for N times and each time repeat it for K times to write down a KN matrix B, in which each element is not less than 0 and not greater than 5\\. With the two matrix A and B formed, Alice’s task is to perform the following 4-step calculation.\r\n!--more--\r\nStep 1: Calculate a new NN matrix C = AB.\r\nStep 2: Calculate M = C^(N*N).\r\nStep 3: For each element x in M, calculate x % 6\\. All the remainders form a new matrix M’.\r\nStep 4: Calculate the sum of all the elements in M’.\r\n\r\nBob just made this problem for kidding but he sees Alice taking it serious, so he also wonders what the answer is. And then Bob turn to you for help because he is not good at math.\r\n\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Input/div\r\ndiv class=\"panel_content\"\r\n\r\nThe input contains several test cases. Each test case starts with two integer N and K, indicating the numbers N and K described above. Then N lines follow, and each line has K integers between 0 and 5, representing matrix A. Then K lines follow, and each line has N integers between 0 and 5, representing matrix B.\r\n\r\nThe end of input is indicated by N = K = 0.\r\n\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Output/div\r\ndiv class=\"panel_content\"For each case, output the sum of all the elements in M’ in a line./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Input/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"4 2 5 5 4 4 5 4 0 0 4 2 5 5 1 3 1 5 6 3 1 2 3 0 3 0 2 3 4 4 3 2 2 5 5 0 5 0 3 4 5 1 1 0 5 3 2 3 3 2 3 1 5 4 5 2 0 0/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Output/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"14 56/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Source/div\r\ndiv class=\"panel_content\" 2014 Multi-University Training Contest 9 /div\r\nbr/\r\n\r\n- -\r\n\r\n\r\ndiv class=\"panel_content\"这题让我注意了矩阵模板的开销问题。1000X1000多次调用就会爆内存了。下面是用动态数组写的。效率非常慢，难以接受。/div\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;cmath&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine PR pair&lt;int,int&gt;\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine Sz(x) (int)x.size()\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clr(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\n/start/\r\ndefine MOD 6\r\nint n, k;\r\nstruct Matrix {\r\n    int n, m;\r\n    int** M;\r\n    Matrix(int n, int m) :n(n), m(m) {\r\n        M = new int*[n];\r\n        for (int i = 0; i &lt; n; i++)\r\n            M[i] = new int[m];\r\n    }\r\n\r\n    Matrix(int n, int m, int k) :\r\n            n(n), m(m) {\r\n        M = new int*[n];\r\n        for (int i = 0; i &lt; n; i++)\r\n            M[i] = new int[m];\r\n        Init(k);\r\n    }\r\n\r\n    ~Matrix() {\r\n        if (M) {\r\n            for (int i = 0; i &lt; n; i++) {\r\n                if (M[i]) {\r\n                    delete[] M[i];\r\n                    M[i] = NULL;\r\n                }\r\n            }\r\n            delete[] M;\r\n            M = NULL;\r\n        }\r\n    }\r\n\r\n    void Init(bool k) { //k=1 返回单位矩阵，k=0 返回零矩阵\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++)\r\n                Mi = k * (i == j);\r\n    }\r\n\r\n    void out() {\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++)\r\n                printf(\"%d%c\", Mi, j == m - 1 ? '\\n' : ' ');\r\n    }\r\n\r\n    Matrix &amp; operator=(const Matrix&amp; othr) {\r\n        this-&gt;~Matrix();\r\n        n = othr.n;\r\n        m = othr.m;\r\n        M = new int*[n];\r\n        for (int i = 0; i &lt; n; i++)\r\n            M[i] = new int[m];\r\n        for (int i = 0; i &lt; n; i++) {\r\n            for (int j = 0; j &lt; m; j++) {\r\n                Mi = othr.Mi;\r\n            }\r\n        }\r\n        return *this;\r\n    }\r\n\r\n    Matrix(const Matrix &amp; othr) {\r\n        n = othr.n;\r\n        m = othr.m;\r\n        M = new int*[n];\r\n        for (int i = 0; i &lt; n; i++)\r\n            M[i] = new int[m];\r\n        for (int i = 0; i &lt; n; i++) {\r\n            for (int j = 0; j &lt; m; j++) {\r\n                Mi = othr.Mi;\r\n            }\r\n        }\r\n    }\r\n\r\n    bool operator==(const Matrix&amp; othr) const {\r\n        if (n - othr.n || m - othr.m) return false;\r\n        for (int i = 0; i &lt; n; i++) {\r\n            for (int j = 0; j &lt; m; j++) {\r\n                if (Mi != othr.Mi) return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    Matrix operator *(const Matrix&amp; othr) const {\r\n        if (m - othr.n) exit(1); //异常退出\r\n        Matrix ans(n, othr.m, 0);\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; othr.m; j++)\r\n                for (int k = 0; k &lt; m; k++) {\r\n                    ans.Mi += Mi * othr.Mk % MOD;\r\n                    if (ans.Mi &gt;= MOD) ans.Mi -= MOD;\r\n                    if (ans.Mi &lt; 0) ans.Mi += MOD;\r\n                }\r\n        return ans;\r\n    }\r\n    Matrix operator *(const int&amp; x) const {\r\n        Matrix ans(n, m);\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++)\r\n                ans.Mi = Mi * x % MOD;\r\n        return ans;\r\n    }\r\n    Matrix operator +(const Matrix &amp; othr) const {\r\n        if (n - othr.n || m - othr.m) exit(1);\r\n        Matrix ans(n, m);\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++) {\r\n                ans.Mi = Mi + othr.Mi;\r\n                if (ans.Mi &gt;= MOD) ans.Mi -= MOD;\r\n                if (ans.Mi &lt; 0) ans.Mi += MOD;\r\n            }\r\n        return ans;\r\n    }\r\n\r\n    Matrix operator -(const Matrix&amp; othr) const {\r\n        if (n - othr.n || m - othr.m) exit(1);\r\n        Matrix ans(n, m);\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++) {\r\n                ans.Mi = Mi - othr.Mi;\r\n                if (ans.Mi &gt;= MOD) ans.Mi -= MOD;\r\n                if (ans.Mi &lt; 0) ans.Mi += MOD;\r\n            }\r\n        return ans;\r\n    }\r\n\r\n    Matrix operator ^(int x) const {\r\n        if (n - m) exit(1);\r\n        Matrix ans(n, m, 1), base = *this;\r\n        while (x &gt; 0) {\r\n            if (x &amp; 1) ans = ans * base;\r\n            base = base * base;\r\n            x &gt;&gt;= 1;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\nint main(int argc, char **argv) {\r\n    while (~scanf(\"%d%d\", &amp;n, &amp;k)) {\r\n        if (n == 0 &amp;&amp; k == 0) break;\r\n        Matrix A(n, k, 0), B(k, n, 0);\r\n        for (int i = 0; i &lt; n; i++) {\r\n            for (int j = 0; j &lt; k; j++) {\r\n                scanf(\"%d\", &amp;A.Mi);\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; k; i++) {\r\n            for (int j = 0; j &lt; n; j++) {\r\n                scanf(\"%d\", &amp;B.Mi);\r\n            }\r\n        }\r\n        Matrix mat = B * A;\r\n        int r = n * n - 1;\r\n        Matrix res = A * (mat ^ r) * B;\r\n        int ans = 0;\r\n        for (int i = 0; i &lt; n; i++) {\r\n            for (int j = 0; j &lt; n; j++) {\r\n                ans += res.Mi;\r\n            }\r\n        }\r\n        printf(\"%d\\n\", ans);\r\n    }\r\n}\r\n`\r\n\r\n然后又试了试vector，虽然简单不少，但是仍然很慢：\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;cmath&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine PR pair&lt;int,int&gt;\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine Sz(x) (int)x.size()\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clr(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\n/start/\r\ndefine MOD 6\r\nint n, k;\r\nstruct Matrix {\r\n    int n, m;\r\n    vector&lt;vector&lt;int&gt; &gt;M;\r\n    Matrix(int n, int m) :n(n), m(m) {\r\n        alloc();\r\n    }\r\n\r\n    Matrix(int n, int m, int k) :\r\n            n(n), m(m) {\r\n        alloc();\r\n        Init(k);\r\n    }\r\n    void alloc(){\r\n        M.resize(n);\r\n        for (int i = 0; i &lt; n; i++)\r\n            M[i].resize(m);\r\n    }\r\n\r\n    void Init(bool k) { //k=1 返回单位矩阵，k=0 返回零矩阵\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++)\r\n                Mi = k * (i == j);\r\n    }\r\n\r\n    void out() {\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++)\r\n                printf(\"%d%c\", Mi, j == m - 1 ? '\\n' : ' ');\r\n    }\r\n\r\n    bool operator==(const Matrix&amp; othr) const {\r\n        if (n - othr.n || m - othr.m) return false;\r\n        for (int i = 0; i &lt; n; i++) {\r\n            for (int j = 0; j &lt; m; j++) {\r\n                if (Mi != othr.Mi) return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    Matrix operator *(const Matrix&amp; othr) const {\r\n        if (m - othr.n) exit(1); //异常退出\r\n        Matrix ans(n, othr.m, 0);\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; othr.m; j++)\r\n                for (int k = 0; k &lt; m; k++) {\r\n                    ans.Mi += Mi * othr.Mk % MOD;\r\n                    if (ans.Mi &gt;= MOD) ans.Mi -= MOD;\r\n                    if (ans.Mi &lt; 0) ans.Mi += MOD;\r\n                }\r\n        return ans;\r\n    }\r\n    Matrix operator *(const int&amp; x) const {\r\n        Matrix ans(n, m);\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++)\r\n                ans.Mi = Mi * x % MOD;\r\n        return ans;\r\n    }\r\n    Matrix operator +(const Matrix &amp; othr) const {\r\n        if (n - othr.n || m - othr.m) exit(1);\r\n        Matrix ans(n, m);\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++) {\r\n                ans.Mi = Mi + othr.Mi;\r\n                if (ans.Mi &gt;= MOD) ans.Mi -= MOD;\r\n                if (ans.Mi &lt; 0) ans.Mi += MOD;\r\n            }\r\n        return ans;\r\n    }\r\n\r\n    Matrix operator -(const Matrix&amp; othr) const {\r\n        if (n - othr.n || m - othr.m) exit(1);\r\n        Matrix ans(n, m);\r\n        for (int i = 0; i &lt; n; i++)\r\n            for (int j = 0; j &lt; m; j++) {\r\n                ans.Mi = Mi - othr.Mi;\r\n                if (ans.Mi &gt;= MOD) ans.Mi -= MOD;\r\n                if (ans.Mi &lt; 0) ans.Mi += MOD;\r\n            }\r\n        return ans;\r\n    }\r\n\r\n    Matrix operator ^(int x) const {\r\n        if (n - m) exit(1);\r\n        Matrix ans(n, m, 1), base = *this;\r\n        while (x &gt; 0) {\r\n            if (x &amp; 1) ans = ans * base;\r\n            base = base * base;\r\n            x &gt;&gt;= 1;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\nint main(int argc, char **argv) {\r\n    while (~scanf(\"%d%d\", &amp;n, &amp;k)) {\r\n        if (n == 0 &amp;&amp; k == 0) break;\r\n        Matrix A(n, k, 0), B(k, n, 0);\r\n        for (int i = 0; i &lt; n; i++) {\r\n            for (int j = 0; j &lt; k; j++) {\r\n                scanf(\"%d\", &amp;A.Mi);\r\n            }\r\n        }\r\n        for (int i = 0; i &lt; k; i++) {\r\n            for (int j = 0; j &lt; n; j++) {\r\n                scanf(\"%d\", &amp;B.Mi);\r\n            }\r\n        }\r\n        Matrix mat = B * A;\r\n        int r = n * n - 1;\r\n        Matrix res = A * (mat ^ r) * B;\r\n        int ans = 0;\r\n        for (int i = 0; i &lt; n; i++) {\r\n            for (int j = 0; j &lt; n; j++) {\r\n                ans += res.Mi;\r\n            }\r\n        }\r\n        printf(\"%d\\n\", ans);\r\n    }\r\n}\r\n`\r\n感觉其他方法还比较麻烦。算了就这样吧~\r\n\r\n&nbsp;",
        "tags": [
            "[矩阵,暴力]"
        ]
    },
    {
        "uri": "/post/hdu4005-the-war",
        "title": "HDU4005 The war",
        "content": "\r\n\r\n**span style=\"font-family: Arial; font-size: 12px; font-weight: bold; color: green;\"Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65768/65768 K (Java/Others)\r\nTotal Submission(s): 1992    Accepted Submission(s): 440\r\n/span**\r\ndiv class=\"panel_title\" align=\"left\"Problem Description/div\r\ndiv class=\"panel_content\"In the war, the intelligence about the enemy is very important. Now, our troop has mastered the situation of the enemy's war zones, and known that these war zones can communicate to each other directly or indirectly through the network. We also know the enemy is going to build a new communication line to strengthen their communication network. Our task is to destroy their communication network, so that some of their war zones can't communicate. Each line has its \"cost of destroy\". If we want to destroy a line, we must spend the \"cost of destroy\" of this line. We want to finish this task using the least cost, but our enemy is very clever. Now, we know the network they have already built, but we know nothing about the new line which our enemy is going to build. In this condition, your task is to find the minimum cost that no matter where our enemy builds the new line, you can destroy it using the fixed money. Please give the minimum cost. For efficiency, we can only destroy one communication line./div\r\n!--more--\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Input/div\r\ndiv class=\"panel_content\"The input contains several cases. For each cases, the first line contains two positive integers n, m (1&lt;=n&lt;=10000, 0&lt;=m&lt;=100000) standing for the number of the enemy's war zones (numbered from 1 to n), and the number of lines that our enemy has already build. Then m lines follow. For each line there are three positive integer a, b, c (1&lt;=a, b&lt;=n, 1&lt;=c&lt;=100000), meaning between war zone A and war zone B there is a communication line with the \"cost of destroy \" c./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Output/div\r\ndiv class=\"panel_content\"For each case, if the task can be finished output the minimum cost, or output ‐1./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Input/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"3 2 1 2 1 2 3 2 4 3 1 2 1 1 3 2 1 4 3/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Output/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"-1 3\r\ndiv style=\"font-family: Times New Roman; font-size: 14px; background-color: f4fbff; border: #B7CBFF 1px dashed; padding: 6px;\"\r\ndiv style=\"font-family: Arial; font-weight: bold; color: #7ca9ed; border-bottom: #B7CBFF 1px dashed;\"Hint/div\r\nFor the second sample input: our enemy may build line 2 to 3, 2 to 4, 3 to 4\\. If they build line 2 to 3, we will destroy line 1 to 4, cost 3\\. If they build line 2 to 4, we will destroy line 1 to 3, cost 2\\. If they build line 3 to 4, we will destroy line 1 to 2, cost 1\\. So, if we want to make sure that we can destroy successfully, the minimum cost is 3.\r\n\r\n/div\r\n&nbsp;\r\n\r\n/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Source/div\r\ndiv class=\"panel_content\" The 36th ACM/ICPC Asia Regional Dalian Site —— Online Contest /div\r\ndiv class=\"panel_content\"/div\r\ndiv class=\"panel_content\"/div\r\ndiv class=\"panel_content\"求无向图边双连通分量缩点，然后DP求第二长边。/div\r\ndiv class=\"panel_content\"\r\npre class=\"EnlighterJSRAW\" data-enlighter-language=\"null\"//#pragma comment(linker, \"/STACK:1024000000,1024000000\")//C++加栈\r\ninclude\r\ninclude\r\ninclude\r\ninclude\r\ninclude\r\ninclude\r\ninclude\r\nincludemap\r\ninclude\r\ninclude\r\ninclude\r\nusing namespace std;\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\n\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\ndefine N 10005\r\ndefine M 100005\r\nint n, m;\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\nstruct edge {\r\n\tint v, w, nxt;\r\n\tbool mark;\r\n} e[M &lt;&lt; 1];\r\nstruct bridge {\r\n\tint u, v, w;\r\n\tbridge(int u, int v, int w) {\r\n\t\tthis-&gt;u = u;\r\n\t\tthis-&gt;w = w;\r\n\t\tthis-&gt;v = v;\r\n\t}\r\n};\r\nint pos, head[N];\r\nint top, stk[N];\r\nint pre[N], dfs_clock, belong[N], bcnt;\r\nvector brg;\r\nvoid InitEdge() {\r\n\tmemset(head, -1, sizeof(head));\r\n\tpos = 0;\r\n}\r\nvoid add(int u, int v, int w) {\r\n\te[pos].v = v;\r\n\te[pos].w = w;\r\n\te[pos].nxt = head[u];\r\n\thead[u] = pos++;\r\n}\r\nint dfs(int u,int fa) {\r\n\tint lowu = pre[u] = ++dfs_clock;\r\n\tstk[top++] = u;\r\n\tbool vis=true;\r\n\tfor (int i = head[u]; ~i; i = e[i].nxt) {\r\n\t\tint v = e[i].v;\r\n\t\tif(v==fa &amp;&amp; vis){\r\n\t\t\tvis=false;//重边\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (!pre[v]) {\r\n\t\t\tint lowv = dfs(v,u);\r\n\t\t\tlowu = min(lowu, lowv);\r\n\t\t\tif (lowv &gt; pre[u]) { //u-v为桥\r\n\t\t\t\tbrg.push_back(bridge(u, v, e[i].w));\r\n\t\t\t}\r\n\t\t} else lowu = min(lowu, pre[v]);\r\n\t}\r\n\tif (pre[u] == lowu) {\r\n\t\tbcnt++;\r\n\t\tdo {\r\n\t\t\tbelong[stk[--top]] = bcnt;\r\n\t\t} while (stk[top] != u);\r\n\t}\r\n\treturn lowu;\r\n}\r\nvoid tarjan() {\r\n\ttop = bcnt = dfs_clock = 0;\r\n\tmemset(pre, 0, sizeof(pre));\r\n\tmemset(belong, 0, sizeof(belong));\r\n\tbrg.clear();\r\n\tfor (int i = 1; i &lt;= n; i++) {\r\n\t\tif (!pre[i])dfs(i,-1);\r\n\t}\r\n}\r\nvoid rebuild() { //根据桥来缩点重构图\r\n\tInitEdge();\r\n\tfor (int i = 0; i &lt; (int) brg.size(); i++) {\r\n\t\tint u = belong[brg[i].u];\r\n\t\tint v = belong[brg[i].v];\r\n\t\tint w = brg[i].w;\r\n\t\tadd(u, v, w);\r\n\t\tadd(v, u, w);\r\n\t}\r\n}\r\nint res;\r\nint DP(int u, int fa) {\r\n\tint Min = inf;\r\n\tfor (int i = head[u]; ~i; i = e[i].nxt) {\r\n\t\tint v = e[i].v;\r\n\t\tif (v == fa)continue;\r\n\t\tint w = DP(v, u);\r\n\t\tw = min(w, e[i].w);\r\n\t\tif (Min &gt; w) {\r\n\t\t\tres = min(res, Min);\r\n\t\t\tMin = w;\r\n\t\t} else res = min(res, w);\r\n\t}\r\n\treturn Min;\r\n}\r\nint main() {\r\n\twhile (~scanf(\"%d%d\", &amp;n, &amp;m)) {\r\n\t\tint u, v, w;\r\n\t\tInitEdge();\r\n\t\tfor (int i = 0; i &lt; m; i++) {\r\n\t\t\tscanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);\r\n\t\t\tadd(u, v, w);\r\n\t\t\tadd(v, u, w);\r\n\t\t}\r\n\t\ttarjan();\r\n\t\trebuild();\r\n\t\tbridge minbrg(-1, -1, inf);\r\n\t\tfor (int i = 0; i &lt; (int) brg.size(); i++) {\r\n\t\t\tif (brg[i].w &lt; minbrg.w) {\r\n\t\t\t\tminbrg = brg[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tres = inf;\r\n\t\tDP(belong[minbrg.u], belong[minbrg.v]);\r\n\t\tDP(belong[minbrg.v], belong[minbrg.u]);\r\n\t\tif(res==inf)res=-1;\r\n\t\tprintf(\"%d\\n\", res);\r\n\t}\r\n}\r\n/pre\r\n/div",
        "tags": [
            "tarjan",
            "树形DP",
            "图论"
        ]
    },
    {
        "uri": "/post/hdu4612-warm-up",
        "title": "HDU4612 Warm up",
        "content": "\r\n\r\n\r\n**span style=\"font-family: Arial; font-size: 12px; font-weight: bold; color: green;\"Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 65535/65535 K (Java/Others)\r\nTotal Submission(s): 3532    Accepted Submission(s): 813/span**\r\ndiv class=\"panel_title\" align=\"left\"Problem Description/div\r\ndiv class=\"panel_content\"　 　N planets are connected by M bidirectional channels that allow instant transportation. It's always possible to travel between any two planets through these channels.\r\nIf we can isolate some planets from others by breaking only one channel , the channel is called a bridge of the transportation system.\r\nPeople don't like to be isolated. So they ask what's the minimal number of bridges they can have if they decide to build a new channel.\r\nNote that there could be more than one channel between two planets./div\r\n!--more--\r\ndiv class=\"panel_title\" align=\"left\"Input/div\r\ndiv class=\"panel_content\"　　The input contains multiple cases.\r\nEach case starts with two positive integers N and M , indicating the number of planets and the number of channels.\r\n(2&lt;=N&lt;=200000, 1&lt;=M&lt;=1000000)\r\nNext M lines each contains two positive integers A and B, indicating a channel between planet A and B in the system. Planets are numbered by 1..N.\r\nA line with two integers '0' terminates the input./div\r\ndiv class=\"panel_title\" align=\"left\"Output/div\r\ndiv class=\"panel_content\"　　For each case, output the minimal number of bridges after building a new channel in a line./div\r\ndiv class=\"panel_title\" align=\"left\"Sample Input/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"4 4 1 2 1 3 1 4 2 3 0 0/div\r\n/div\r\ndiv class=\"panel_title\" align=\"left\"Sample Output/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"0/div\r\n/div\r\ndiv class=\"panel_title\" align=\"left\"Source/div\r\ndiv class=\"panel_content\" 2013 Multi-University Training Contest 2 /div\r\nbr/\r\n\r\n- -\r\n\r\n\r\n`C++\r\npragma comment(linker, \"/STACK:1024000000,1024000000\")//C++加栈\r\ninclude\r\ninclude\r\ninclude\r\ninclude\r\ninclude\r\ninclude\r\ninclude\r\nincludemap\r\ninclude\r\ninclude\r\ninclude\r\nusing namespace std;\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\n\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\ndefine N 200005\r\ndefine M 1000005\r\nint n, m;\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\nstruct edge {\r\n\tint v, nxt;\r\n} e[M &lt;&lt; 1];\r\nstruct bridge {\r\n\tint u, v;\r\n\tbridge(int u, int v) {\r\n\t\tthis-&gt;u = u;\r\n\t\tthis-&gt;v = v;\r\n\t}\r\n};\r\nint pos, head[N];\r\nint top, stk[N];\r\nint pre[N], dfs_clock, belong[N], bcnt;\r\nvector brg;\r\nvoid InitEdge() {\r\n\tmemset(head, -1, sizeof(head));\r\n\tpos = 0;\r\n}\r\nvoid add(int u, int v) {\r\n\te[pos].v = v;\r\n\te[pos].nxt = head[u];\r\n\thead[u] = pos++;\r\n}\r\nint dfs(int u, int fa) {\r\n\tint lowu = pre[u] = ++dfs_clock;\r\n\tstk[top++] = u;\r\n\tbool vis = true;\r\n\tfor (int i = head[u]; ~i; i = e[i].nxt) {\r\n\t\tint v = e[i].v;\r\n\t\tif (v == fa &amp;&amp; vis) {\r\n\t\t\tvis = false; //u-v的反向边一定是v-u邻接表里的第一条边。\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (!pre[v]) {\r\n\t\t\tint lowv = dfs(v, u);\r\n\t\t\tlowu = min(lowu, lowv);\r\n\t\t\tif (lowv &gt; pre[u]) { //u-v为桥\r\n\t\t\t\tbrg.push_back(bridge(u, v));\r\n\t\t\t}\r\n\t\t} else lowu = min(lowu, pre[v]);\r\n\t}\r\n\tif (pre[u] == lowu) {\r\n\t\tbcnt++;\r\n\t\tdo {\r\n\t\t\tbelong[stk[--top]] = bcnt;\r\n\t\t} while (stk[top] != u);\r\n\t}\r\n\treturn lowu;\r\n}\r\nvoid tarjan() {\r\n\ttop = bcnt = dfs_clock = 0;\r\n\tmemset(pre, 0, sizeof(pre));\r\n\tmemset(belong, 0, sizeof(belong));\r\n\tbrg.clear();\r\n\tfor (int i = 1; i &lt;= n; i++) {\r\n\t\tif (!pre[i]) dfs(i, -1);\r\n\t}\r\n}\r\nvoid rebuild() { //根据桥来缩点重构图\r\n\tInitEdge();\r\n\tfor (int i = 0; i &lt; (int) brg.size(); i++) {\r\n\t\tint u = belong[brg[i].u];\r\n\t\tint v = belong[brg[i].v];\r\n\t\tadd(u, v);\r\n\t\tadd(v, u);\r\n\t}\r\n}\r\nint diameter = 0;\r\nint findR(int u, int fa) {\r\n\tint h1 = 0, h2 = 0; // 以u为根，h1最高的儿子，h2次高儿子。放在dfs里面两者不会重合。\r\n\tfor (int i = head[u]; ~i; i = e[i].nxt) {\r\n\t\tint v = e[i].v;\r\n\t\tif (v == fa) continue;\r\n\t\tint h = findR(v, u) + 1; //若路径有权重，则把1改为u-v的权重\r\n\t\tif (h &gt; h1) h2 = h1, h1 = h;\r\n\t\telse h2 = max(h, h2);\r\n\t}\r\n\tdiameter = max(diameter, h1 + h2);\r\n\treturn h1;\r\n}\r\nvoid tree_diameter() {\r\n\tdiameter = 0;\r\n\tfindR(1, -1);\r\n}\r\nint main() {\r\n\twhile (scanf(\"%d%d\", &amp;n, &amp;m), n || m) {\r\n\t\tint u, v;\r\n\t\tInitEdge();\r\n\t\tfor (int i = 0; i &lt; m; i++) {\r\n\t\t\tscanf(\"%d%d\", &amp;u, &amp;v);\r\n\t\t\tadd(u, v);\r\n\t\t\tadd(v, u);\r\n\t\t}\r\n\t\ttarjan();\r\n\t\trebuild();\r\n\t\ttree_diameter();\r\n\t\tprintf(\"%d\\n\", bcnt - diameter - 1);\r\n\t}\r\n}\r\n`",
        "tags": [
            "tarjan",
            "图论",
            "树的直径"
        ]
    },
    {
        "uri": "/post/hdu4888-redraw-beautiful-drawings",
        "title": "HDU4888 Redraw Beautiful Drawings ",
        "content": "\r\n\r\ndiv class=\"panel_title\" align=\"left\"Problem Description/div\r\ndiv class=\"panel_content\"Alice and Bob are playing together. Alice is crazy about art and she has visited many museums around the world. She has a good memory and she can remember all drawings she has seen.Today Alice designs a game using these drawings in her memory. First, she matches K+1 colors appears in the picture to K+1 different integers(from 0 to K). After that, she slices the drawing into grids and there are N rows and M columns. Each grid has an integer on it(from 0 to K) representing the color on the corresponding position in the original drawing. Alice wants to share the wonderful drawings with Bob and she tells Bob the size of the drawing, the number of different colors, and the sum of integers on each row and each column. Bob has to redraw the drawing with Alice's information. Unfortunately, somtimes, the information Alice offers is wrong because of Alice's poor math. And sometimes, Bob can work out multiple different drawings using the information Alice provides. Bob gets confused and he needs your help. You have to tell Bob if Alice's information is right and if her information is right you should also tell Bob whether he can get a unique drawing./div\r\ndiv class=\"panel_bottom\"/div\r\n!--more--\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Input/div\r\ndiv class=\"panel_content\"The input contains mutiple testcases.For each testcase, the first line contains three integers N(1 ≤ N ≤ 400) , M(1 ≤ M ≤ 400) and K(1 ≤ K ≤ 40).\r\nN integers are given in the second line representing the sum of N rows.\r\nM integers are given in the third line representing the sum of M columns.The input is terminated by EOF./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Output/div\r\ndiv class=\"panel_content\"For each testcase, if there is no solution for Bob, output \"Impossible\" in one line(without the quotation mark); if there is only one solution for Bob, output \"Unique\" in one line(without the quotation mark) and output an N * M matrix in the following N lines representing Bob's unique solution; if there are many ways for Bob to redraw the drawing, output \"Not Unique\" in one line(without the quotation mark)./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Input/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"2 2 4 4 2 4 2 4 2 2 2 2 5 0 5 4 1 4 3 9 1 2 3 3/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Output/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"Not Unique Impossible Unique 1 2 3 3/div\r\n/div\r\n&nbsp;\r\n\r\n- -\r\n\r\n\r\n第一步，考虑如何求是否有解。使用网络流求解，每一行和每一列分别对应一个点，加上源点和汇点一共有N+M+2个点。有三类边：\r\n\r\n\r\n\r\n源点 -&gt; 每一行对应的点，流量限制为该行的和\r\n每一行对应的点 -&gt; 每一列对应的点，流量限制为 K\r\n每一列对应的点 -&gt; 汇点，流量限制为该列的和\r\n&nbsp;\r\n\r\n对上图做最大流，若源点出发的边和到达汇点的边全都满流，则有解，否则无解。若要求构造方案，则 (i,j) 对应的整数就是行 i–&gt; 列 j 的流量。\r\n\r\n第二步，考虑解是否唯一。显然，解唯一的充分必要条件是完成最大流后的残余网络没有长度大于 2 的环。所以，判断解的唯一性可使用dfs，注意遍历的时候不可以在走完一条边后马上走其反向边，加此限制检查是否有环即可判断解是否唯一。\r\n\r\n至此，全题已解决。\r\n`C++\r\ninclude &lt;iostream&gt; \r\ninclude &lt;cstring&gt; \r\ninclude &lt;cstdio&gt; \r\ninclude &lt;queue&gt; \r\ninclude &lt;cstdlib&gt;\r\nusing namespace std;\r\n\r\nconst int maxn=500,maxm=maxn*maxn;\r\nint nextmaxm2],num[maxm2],r[maxm2],a[maxn2],rowsum[maxn],colsum[maxn],n,m,K,tt,T,d[maxn2],st[maxn2],cod[maxn;\r\nint h[maxn2],vh[maxn2];\r\nbool don[maxm2],in[maxn2];\r\n\r\nvoid insert(int x,int y,int rr)\r\n{\r\n\tnext[++tt]=a[x];num[tt]=y;r[tt]=rr;a[x]=tt;\r\n\tnext[++tt]=a[y];num[tt]=x;r[tt]=0;a[y]=tt;\r\n}\r\n\r\nvoid construct()\r\n{\r\n\ttt=1;T=n+m+1;\r\n\tfor (int i=0;i&lt;=T;i++) a[i]=0;\r\n\tfor (int i=1;i&lt;=n;i++) insert(0,i,row_sum[i]);\r\n\tfor (int i=1;i&lt;=m;i++) insert(i+n,T,col_sum[i]);\r\n\tfor (int i=1;i&lt;=n;i++)\r\n\t{\r\n\t\tfor (int j=1;j&lt;=m;j++)\r\n\t\t{\r\n\t\t\tinsert(i,j+n,K);\r\n\t\t\tcodi=tt;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint dfs(int x,int y)\r\n{\r\n\tif (x==T) return y;\r\n\tint sig=st[x],minh=T+1;\r\n\tdo\r\n\t{\r\n\t\tif (r[st[x]])\r\n\t\t{\r\n\t\t\tif (h[num[st[x]]]+1==h[x])\r\n\t\t\t{\r\n\t\t\t\tint k=dfs(num[st[x]],min(y,r[st[x]]));\r\n\t\t\t\tif (k)\r\n\t\t\t\t{\r\n\t\t\t\t\tr[st[x]]-=k;\r\n\t\t\t\t\tr[st[x]^1]+=k;\r\n\t\t\t\t\treturn k;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tminh=min(minh,h[num[st[x]]]+1);\r\n\t\t\tif (h[0]&gt;T) return 0;\r\n\t\t}\r\n\t\tst[x]=next[st[x]];\r\n\t\tif (st[x]==0) st[x]=a[x];\r\n\t}while (sig!=st[x]);\r\n\tif (vh[h[x]]--==0) h[0]=T+1;\r\n\tvh[h[x]=minh]++;\r\n\treturn 0;\r\n}\r\n\r\nint max_flow()\r\n{\r\n\tfor (int i=0;i&lt;=T;i++) h[i]=vh[i]=0;\r\n\tfor (int i=0;i&lt;=T;i++) st[i]=a[i];\r\n\tvh[0]=T+1;\r\n\tint ret=0;\r\n\twhile (h[0]&lt;=T) ret+=dfs(0,K+1);\r\n\treturn ret;\r\n}\r\n\r\n/*bool find_circle()\r\n{\r\n\tdeque  q;\r\n\tfor (int i=0;i&lt;=T;i++) d[i]=0;\r\n\tfor (int i=0;i&lt;=T;i++)\r\n\t{\r\n\t\tfor (int p=a[i];p;p=next[p])\r\n\t\t{\r\n\t\t\tif (r[p]) d[i]++;\r\n\t\t}\r\n\t\tif (d[i]==0) q.push_back(i);\r\n\t}\r\n\tint cnt=T+1;\r\n\twhile (!q.empty())\r\n\t{\r\n\t\tint x=q.front();\r\n\t\tcnt--;\r\n\t\tq.pop_front();\r\n\t\tfor (int p=a[x];p;p=next[p])\r\n\t\t{\r\n\t\t\tif (r[p^1]) \r\n\t\t\t{\r\n\t\t\t\td[num[p]]--;\r\n\t\t\t\tif (d[num[p]]==0) q.push_back(num[p]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn cnt;\r\n}*/\r\n\r\nbool visit(int x,int ed)\r\n{\r\n\tif (don[ed]) \r\n\t\treturn in[x];\r\n\tdon[ed]=true;\r\n\tin[x]=true;\r\n\tfor (int p=a[x];p;p=next[p])\r\n\t{\r\n\t\tif (r[p] &amp;&amp; (ed^p)!=1)\r\n\t\t\tif (visit(num[p],p)) return true;\r\n\t}\r\n\tin[x]=false;\r\n\treturn false;\r\n}\r\n\r\nbool find_circle()\r\n{\r\n\tfor (int i=0;i&lt;=T;i++) in[i]=false;\r\n\tfor (int i=1;i&lt;=tt;i++) don[i]=false;\r\n\tint col=0;\r\n\tfor (int i=2;i&lt;=tt;i++)\r\n\t{\r\n\t\tif (r[i] &amp;&amp; !don[i])\r\n\t\t{\r\n\t\t\tin[num[i^1]]=true;\r\n\t\t\tif (visit(num[i],i)) return true; \r\n\t\t\tin[num[i^1]]=false;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid print_scheme()\r\n{\r\n\tprintf(\"Unique\\n\");\r\n\tfor (int i=1;i&lt;=n;i++)\r\n\t{\r\n\t\tprintf(\"%d\",rcod[i]);\r\n\t\tfor (int j=2;j&lt;=m;j++) printf(\" %d\",rcod[i]);\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\twhile (scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;K)!=EOF)\r\n\t{\r\n\t\tint tmp=0;\r\n\t\tfor (int i=1;i&lt;=n;i++)\r\n\t\t{\r\n\t\t\tscanf(\"%d\",&amp;row_sum[i]);\r\n\t\t\ttmp+=row_sum[i];\r\n\t\t}\r\n\t\tint sum=tmp;\r\n\t\tfor (int i=1;i&lt;=m;i++)\r\n\t\t{\r\n\t\t\tscanf(\"%d\",&amp;col_sum[i]);\r\n\t\t\ttmp-=col_sum[i];\r\n\t\t}\r\n\t\tif (tmp) \r\n\t\t{\r\n\t\t\tprintf(\"Impossible\\n\");\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tconstruct();\r\n\t\tif (max_flow()&lt;sum)\r\n\t\t{\r\n\t\t\tprintf(\"Impossible\\n\");\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (find_circle())\r\n\t\t{\r\n\t\t\tprintf(\"Not Unique\\n\");\r\n\t\t}else print_scheme();\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n`",
        "tags": []
    },
    {
        "uri": "/post/hdu4944-fsfs-game",
        "title": "HDU4944 FSF’s game",
        "content": "\r\n\r\n**span style=\"font-family: Arial; font-size: 12px; font-weight: bold; color: green;\"Time Limit: 9000/4500 MS (Java/Others)    Memory Limit: 131072/131072 K (Java/Others)\r\nTotal Submission(s): 166    Accepted Submission(s): 76\r\n/span**\r\ndiv class=\"panel_title\" align=\"left\"Problem Description/div\r\ndiv class=\"panel_content\"FSF has programmed a game.\r\nIn this game, players need to divide a rectangle into several same squares.\r\nThe length and width of rectangles are integer, and of course the side length of squares are integer.\r\n\r\nAfter division, players can get some coins.\r\nIf players successfully divide a AxB rectangle(length: A, width: B) into KxK squares(side length: K), they can get A*B/ gcd(A/K,B/K) gold coins.\r\nIn a level, you can’t get coins twice with same method.\r\n(For example, You can get 6 coins from 2x2(A=2,B=2) rectangle. When K=1, AB/gcd(A/K,B/K)=2; When K=2, AB/gcd(A/K,B/K)=4; 2+4=6; )\r\n!--more--\r\nThere are N*(N+1)/2 levels in this game, and every level is an unique rectangle. (1x1 , 2x1, 2x2, 3x1, ..., Nx(N-1), NxN)\r\n\r\nFSF has played this game for a long time, and he finally gets all the coins in the game.\r\nUnfortunately ,he uses an UNSIGNED 32-BIT INTEGER variable to count the number of coins.\r\nThis variable may overflow.\r\nWe want to know what the variable will be.\r\n(In other words, the number of coins mod 2^32)/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Input/div\r\ndiv class=\"panel_content\"There are multiply test cases.\r\n\r\nThe first line contains an integer T(T&lt;=500000), the number of test cases\r\n\r\nEach of the next T lines contain an integer N(N&lt;=500000)./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Output/div\r\ndiv class=\"panel_content\"Output a single line for each test case.\r\n\r\nFor each test case, you should output \"Case #C: \". first, where C indicates the case number and counts from 1.\r\n\r\nThen output the answer, the value of that UNSIGNED 32-BIT INTEGER variable./div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Input/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"3 1 3 100/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Sample Output/div\r\ndiv class=\"panel_content\"\r\ndiv style=\"font-family: Courier New,Courier,monospace;\"Case #1: 1 \r\nCase #2: 30 \r\nCase #3: 15662489\r\ndiv style=\"font-family: Times New Roman; font-size: 14px; background-color: f4fbff; border: #B7CBFF 1px dashed; padding: 6px;\"\r\ndiv style=\"font-family: Arial; font-weight: bold; color: #7ca9ed; border-bottom: #B7CBFF 1px dashed;\"Hint/div\r\nIn the second test case, there are six levels(1x1,1x2,1x3,2x2,2x3,3x3) Here is the details for this game: 1x1: 1(K=1); 1x2: 2(K=1); 1x3: 3(K=1); 2x2: 2(K=1), 4(K=2); 2x3: 6(K=1); 3x3: 3(K=1), 9(K=3); 1+2+3+2+4+6+3+9=30/div\r\n_ _/div\r\n/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Author/div\r\ndiv class=\"panel_content\"UESTC/div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Source/div\r\ndiv class=\"panel_content\" 2014 Multi-University Training Contest 7 /div\r\ndiv class=\"panel_bottom\"/div\r\n&nbsp;\r\ndiv class=\"panel_title\" align=\"left\"Recommend/div\r\ndiv class=\"panel_content\"We have carefully selected several similar problems for you:  4943 4942 4941 4940 4939/div\r\ndiv class=\"panel_content\"N(LogN)的复杂度。/div\r\n`C++\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;cstring&gt;\r\nusing namespace std;\r\ndefine N 500001\r\nunsigned int f[N];\r\nunsigned int g[N];\r\nint n;\r\nint main() {\r\n    int T;\r\n    for (int i = 1; i &lt; N; i++) {\r\n        for (int j = 1; i * j &lt; N; j++) {\r\n            g[i * j] += (1LL + j) * j / 2;\r\n        }\r\n    }\r\n    f[1] = 1;\r\n    for (int i = 2; i &lt; N; i++) {\r\n        f[i] = f[i - 1] + i * g[i];\r\n    }\r\n    scanf(\"%d\", &amp;T);\r\n    for (int c = 1; c &lt;= T; c++) {\r\n        scanf(\"%d\", &amp;n);\r\n        printf(\"Case %d: %u\\n\", c, f[n]);\r\n    }\r\n}\r\n`\r\n",
        "tags": []
    },
    {
        "uri": "/post/hello-world",
        "title": "网易云音乐新API浅析",
        "content": "\r\n新API采用了略微修改过的AES和RSA加密，主要用在登陆接口上，对新API进行简单的分析。\r\nUrl\r\n估计会抓包的人都知道，Url中的api便成了weapi。比如手机登录：\r\n原来是：http://music.163.com/api/login/cellphone/\r\n现在是：http://music.163.com/weapi/login/cellphone/\r\n\r\n 加密算法\r\n核心过程如下：\r\n\r\n`javascript\r\n aesRsaEncrypt = function (text, pubKey, modulus, nonce) {\r\n  const secKey = createSecretKey(16);  // 随机生成16位加密密钥\r\n  return {\r\n\tparams:  aesEncrypt(aesEncrypt(text, nonce), secKey),\r\n\tencSecKey: rsaEncrypt(secKey, pubKey, modulus)\r\n  }\r\n}\r\n`\r\n!--more--\r\n`javascript\r\n{\r\n\tText : \"JSON.stringify({phone:xxx,password:\"md5 hashed Data\",rememberLogin:\"true\"})\" //需要加密的post body\r\n\tpubKey : \"010001\"\r\n\tnonce : \"0CoJUm6Qyw8W8jud\"\r\n\tmodulus : \"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7\"\r\n}\r\n`\r\n\r\n一些细节\r\nAES加密的具体算法为:AES-128-CBC，输出格式为base64。\r\nAES加密时需要指定iv：0102030405060708\r\nRSA加密输出为Hex格式，公钥是{N:modulus,e:pubKey}\r\n我的Javascript实现：Crypto\r\nRSA算法的JS实现方法参考：http://www.cnblogs.com/kxdhm/archive/2012/02/02/2336103.html\r\n\r\n",
        "tags": []
    },
    {
        "uri": "/post/intro-of-fft",
        "title": "（转）关于卷积的一个血腥的讲解，看完给跪了",
        "content": "\r\n\r\n比如说你的老板命令你干活，你却到楼下打台球去了，后来被老板发现，他非常气愤，扇了你一巴掌（注意，这就是输入信号，脉冲），于是你的脸上会渐渐地（贱贱地）鼓起来一个包，你的脸就是一个系统，而鼓起来的包就是你的脸对巴掌的响应，好，这样就和信号系统建立起来意义对应的联系。下面还需要一些假设来保证论证的严谨：假定你的脸是线性时不变系统，也就是说，无论什么时候老板打你一巴掌，打在你脸的同一位置（这似乎要求你的脸足够光滑，如果你说你长了很多青春痘，甚至整个脸皮处处连续处处不可导，那难度太大了，我就无话可说了哈哈），你的脸上总是会在相同的时间间隔内鼓起来一个相同高度的包来，并且假定以鼓起来的包的大小作为系统输出。好了，那么，下面可以进入核心内容——卷积了！\r\n!--more--\r\n如果你每天都到地下去打台球，那么老板每天都要扇你一巴掌，不过当老板打你一巴掌后，你5分钟就消肿了，所以时间长了，你甚至就适应这种生活了……如果有一天，老板忍无可忍，以0.5秒的间隔开始不间断的扇你的过程，这样问题就来了，第一次扇你鼓起来的包还没消肿，第二个巴掌就来了，你脸上的包就可能鼓起来两倍高，老板不断扇你，脉冲不断作用在你脸上，效果不断叠加了，这样这些效果就可以求和了，结果就是你脸上的包的高度随时间变化的一个函数了（注意理解）；如果老板再狠一点，频率越来越高，以至于你都辨别不清时间间隔了，那么，求和就变成积分了。可以这样理解，在这个过程中的某一固定的时刻，你的脸上的包的鼓起程度和什么有关呢？和之前每次打你都有关！但是各次的贡献是不一样的，越早打的巴掌，贡献越小，所以这就是说，某一时刻的输出是之前很多次输入乘以各自的衰减系数之后的叠加而形成某一点的输出，然后再把不同时刻的输出点放在一起，形成一个函数，这就是卷积，卷积之后的函数就是你脸上的包的大小随时间变化的函数。本来你的包几分钟就可以消肿，可是如果连续打，几个小时也消不了肿了，这难道不是一种平滑过程么？反映到剑桥大学的公式上，f(a)就是第a个巴掌，g(x-a)就是第a个巴掌在x时刻的作用程度，乘起来再叠加就ok了，大家说是不是这个道理呢？我想这个例子已经非常形象了，你对卷积有了更加具体深刻的了解了吗？\r\n\r\n转自GSDzone论坛\r\n\r\n",
        "tags": []
    },
    {
        "uri": "/post/poj1330-nearest-common-ancestors",
        "title": "POJ1330 Nearest Common Ancestors",
        "content": "\r\n\r\nTime Limit: 1000MS Memory Limit: 10000K  \r\nTotal Submissions: 17734 Accepted: 9405\r\n\r\nDescription\r\nA rooted tree is a well-known data structure in computer science and engineering. An example is shown below:\r\n\r\nIn the figure, each node is labeled with an integer from {1, 2,...,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16\\. Node 10 is also an ancestor of node 16\\. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16\\. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7\\. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7\\. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4\\. Node 4 is nearer to nodes 16 and 7 than node 8 is.\r\n!--more--\r\nFor other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4\\. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y.\r\n\r\nWrite a program that finds the nearest common ancestor of two distinct nodes in a tree.\r\n\r\nInput\r\nThe input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000\\. The nodes are labeled with integers 1, 2,..., N. Each of the next N -1 lines contains a pair of integers that represent an edge --the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed.\r\n\r\nOutput\r\nPrint exactly one line for each test case. The line should contain the integer that is the nearest common ancestor.\r\n\r\nSample Input\r\n\r\n2\r\n16\r\n1 14\r\n8 5\r\n10 16\r\n5 9\r\n4 6\r\n8 4\r\n4 10\r\n1 13\r\n6 15\r\n10 11\r\n6 7\r\n10 2\r\n16 3\r\n8 1\r\n16 12\r\n16 7\r\n5\r\n2 3\r\n3 4\r\n3 1\r\n1 5\r\n3 5\r\n\r\nSample Output\r\n\r\n4\r\n3\r\n\r\nSource\r\nTaejon 2002\r\nbr/\r\n\r\n- -\r\n\r\n\r\ntarjan+并查集求LCA模板。将u的子儿子v递归合并到u，若y在x的子树上，则根据并查集的性质，公共祖先即为x（father[y]）。若y和x不再同一子树上。则根据dfs回溯的性质，则搜完y之后一定是回溯到x,y的最近公共祖先才能搜到x的，而此时由并查集的性质，回溯的节点刚好就是father[y]。\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine MP make_pair\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine F first\r\ndefine S second\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clrA(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf=~0u&gt;&gt;1;\r\nconst LL lnf=~0ull&gt;&gt;1;\r\ndefine N 10005\r\ndefine M 10005\r\nint n, m;\r\n//UnionSet\r\nint p[N];\r\nvoid initUset() {\r\n    for (int i = 0; i &lt;= n; i++)\r\n        p[i] = i;\r\n}\r\nint uFind(int x) {\r\n    return x == p[x] ? p[x] : p[x] = uFind(p[x]);\r\n}\r\nvoid uMerge(int x, int y) { //y合并到x\r\n    int fx = uFind(x);\r\n    int fy = uFind(y);\r\n    if (fx != fy)\r\n        p[fy]=fx;\r\n}\r\n//Edge Graph\r\nint head[N], pos;\r\nstruct Edge {\r\n    int v, nxt;\r\n} e[M];\r\nvoid initEdge() {\r\n    memset(head, -1, sizeof(head));\r\n    pos = 0;\r\n}\r\nvoid add(int u, int v) {\r\n    e[pos].v = v;\r\n    e[pos].nxt = head[u];\r\n    head[u] = pos++;\r\n}\r\nint findRoot(){//有向图选择入度为0的点，无向图不同节点做根，LCA结果将不同。\r\n    for (int i = 1; i &lt; n; i++)\r\n        if (indeg[i] == 0) return i;\r\n    return assert(false),-1;\r\n}\r\n//LCA\r\nint size, root;\r\nint vis[N];\r\nint ans[5];\r\nint indeg[N];\r\nvector&lt;pr&lt;int, int&gt; &gt; que[N];\r\nint dfs(int u) {\r\n    int solved=0;\r\n    for (int i = head[u]; ~i; i = e[i].nxt) {\r\n        int v = e[i].v;\r\n        solved+=dfs(v);\r\n        if(solved==size)return solved;\r\n        uMerge(u, v);\r\n    }\r\n    vis[u] = 1;\r\n    for (int i = 0; i &lt; (int) que[u].size(); i++) {\r\n        int v = queu.F;\r\n        if (vis[v]) {\r\n            ansque[u.S] = uFind(v);\r\n            solved++;\r\n        }\r\n    }\r\n    return solved;\r\n}\r\nvoid tarjan() {\r\n    clrA(vis,0);\r\n    dfs(findRoot());\r\n}\r\nint main() {\r\n    int T;\r\n    scanf(\"%d\", &amp;T);\r\n    while (T--) {\r\n        scanf(\"%d\", &amp;n);\r\n        initEdge();\r\n        int u, v;\r\n        clrA(indeg,0);\r\n        for (int i = 1; i &lt; n; i++) {\r\n            scanf(\"%d%d\", &amp;u, &amp;v);\r\n            add(u, v);\r\n            indeg[v]++;\r\n        }\r\n        initUset();\r\n        size = 1;//查询的次数\r\n        for(int i=1;i&lt;=n;i++)que[i].clear();\r\n        for (int i = 1; i &lt;= size; i++) {\r\n            scanf(\"%d%d\", &amp;u, &amp;v);\r\n            que[u].push_back(MP(v, i));\r\n            que[v].push_back(MP(u, i));\r\n        }\r\n        tarjan();\r\n        for (int i = 1; i &lt;= size; i++) {\r\n            printf(\"%d\\n\", ans[i]);\r\n        }\r\n    }\r\n}\r\n`\r\nLCA还可以用倍增来求：（思想很普通，只是以2进制的步长向上走：dpi表示节点i向上走2^j步到达的节点。）\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;cmath&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine qlr(x) while(!x.empty)x.pop();\r\ndefine clr(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\ndefine N 10005\r\ndefine M N-1\r\nint n;\r\nint head[N], pos;\r\nstruct edge {\r\n    int v, nxt;\r\n} e[M];\r\nvoid add(int u, int v) {\r\n    e[pos].v = v;\r\n    e[pos].nxt = head[u];\r\n    head[u] = pos++;\r\n}\r\nvoid initEdge() {\r\n    clr(head, -1);\r\n    pos = 0;\r\n}\r\nint deep[N];\r\nvector&lt;int&gt; dp[N];\r\nint size;\r\nint findRoot() {\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        if (dp[i].empty()) return i;\r\n    }\r\n    return -1;\r\n}\r\nvoid getDeep(int u = findRoot()) {\r\n    for (int i = head[u]; ~i; i = e[i].nxt) {\r\n        int v = e[i].v;\r\n        deep[v] = deep[u] + 1;\r\n        getDeep(v);\r\n    }\r\n    size = max(size, deep[u] + 1);//记录最大深度\r\n}\r\nvoid initLCA() {\r\n    clr(deep, 0);\r\n    size = 0;\r\n    getDeep();\r\n    for (int len = 1,t=2;t&lt;=size; len++,t&lt;&lt;=1) {//跳出条件：(t=2^len)&lt;=size\r\n        for (int i = 1; i &lt;= n; i++) {\r\n            if ((int)dpi].size() &gt;= len &amp;&amp; (int)dp[dp[i].size() &gt;= len) {\r\n                dpi].push_back(dp[dp[i][len-1]);\r\n            }\r\n        }\r\n    }\r\n}\r\nint getLCA(int u, int v) {\r\n    if (deep[u] &lt; deep[v]) swap(u, v);\r\n    int d = deep[u] - deep[v];\r\n    for (int i = 0; d; i++, d &gt;&gt;= 1) {\r\n        u = d &amp; 1 ? dpu : u;\r\n    }//以差值二进制形式将u往上走差值\r\n    if (u == v) return u;\r\n    for (int i = min(dp[u].size(),dp[v].size())-1; i &gt;= 0; i--) {\r\n        if (dpu != dpv) {\r\n            u = dpu;\r\n            v = dpv;\r\n            i=(int)min(dp[u].size(),dp[v].size());//注意每次都要更新i！！\r\n        }\r\n    }\r\n    u = dpu;\r\n    return u;\r\n}\r\nint main() {\r\n    int T;\r\n    cin &gt;&gt; T;\r\n    while (T--) {\r\n        scanf(\"%d\", &amp;n);\r\n        int u, v;\r\n        initEdge();\r\n        for (int i = 1; i &lt;= n; i++)\r\n            dp[i].clear();\r\n        for (int i = 1; i &lt; n; i++) {\r\n            scanf(\"%d%d\", &amp;u, &amp;v);\r\n            add(u, v);\r\n            dp[v].push_back(u);\r\n        }\r\n        initLCA();\r\n        scanf(\"%d%d\", &amp;u, &amp;v);\r\n        printf(\"%d\\n\", getLCA(u, v));\r\n    }\r\n}\r\n`\r\nLCA还可以转化为RMQ问题（个人更喜欢此方法，在线，且效率高）\r\n`C++\r\n//============================================================================\r\n// Name        : test3.cpp\r\n// Author      : \r\n// Version     :\r\n// Copyright   : Your copyright notice\r\n// Description : Hello World in C++, Ansi-style\r\n//============================================================================\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clrA(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\nint n, m;\r\ndefine N 10005\r\ndefine M 10005\r\nint head[N], pos;\r\nstruct Edge {\r\n    int v, nxt;\r\n} e[M];\r\nvoid initEdge() {\r\n    memset(head, -1, sizeof(head));\r\n    pos = 0;\r\n}\r\nvoid add(int u, int v) {\r\n    e[pos].v = v;\r\n    e[pos].nxt = head[u];\r\n    head[u] = pos++;\r\n}\r\n//RMQ\r\nint dpM20;\r\nint lg2[N &lt;&lt; 1 | 1];\r\ndefine getLeft(R,L) (R-(L)+1)\r\nvoid initRMQ(int n) { //dp0表示区间i的值。预先处理出来。\r\n    lg2[0] = -1;\r\n    int limit;\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        lg2[i] = i &amp; (i - 1) ? lg2[i - 1] : lg2[i - 1] + 1;\r\n    }\r\n    for (int i = 1; i &lt;= lg2[n]; i++) {\r\n        limit = getLeft(n, 1 &lt;&lt; i);\r\n        for (int j = 1; j &lt;= limit; j++) {\r\n            dpMi = min(dpMi - 1, dpMi - 1)]);\r\n        }\r\n    }\r\n}\r\nint getRMQ(int x, int y) {\r\n    if (x &gt; y) swap(x, y);\r\n    int t = lg2[y - x + 1];\r\n    return min(dpMt, dpMt]);\r\n}\r\n//LCA\r\nint depth, cnt;\r\nint inde[N], H[N], E[N];\r\n//dp0深度序列（dfs编号），E[N]每个dfs编号对应的节点，H[N]节点第一次出现在dfs编号序列中的位置\r\nint findRoot() {\r\n    for (int i = 1; i &lt;= n; i++)\r\n        if (!inde[i]) return i;\r\n    return -1;\r\n}\r\nvoid getEuler(int u = findRoot()) {\r\n    int dfn = dpM0 = ++cnt] = ++depth;\r\n    E[dfn] = u;\r\n    for (int i = head[u]; ~i; i = e[i].nxt) {\r\n        int v = e[i].v;\r\n        getEuler(v);\r\n        dpM0 = dfn;\r\n    }\r\n}\r\nvoid initLCA() {\r\n    depth = cnt = 0;\r\n    getEuler();\r\n    initRMQ(cnt);\r\n}\r\nint getLCA(int u, int v) {\r\n    if (H[u] &gt; H[v]) swap(u, v);\r\n    return E[getRMQ(H[u], H[v])];\r\n}\r\nint main() {\r\n    int T;\r\n    scanf(\"%d\", &amp;T);\r\n    while (T--) {\r\n        scanf(\"%d\", &amp;n);m=n-1;\r\n        int u, v;\r\n        initEdge();\r\n        memset(inde, 0, sizeof(inde));\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            scanf(\"%d%d\", &amp;u, &amp;v);\r\n            add(u, v);\r\n            inde[v]++;\r\n        }\r\n        initLCA();\r\n        scanf(\"%d%d\", &amp;u, &amp;v);\r\n        printf(\"%d\\n\", getLCA(u, v));\r\n    }\r\n}\r\n`\r\n&nbsp;",
        "tags": [
            "LCA",
            "图论",
            "tarjan",
            "倍增"
        ]
    },
    {
        "uri": "/post/poj1989-distance-queries",
        "title": "POJ1989 Distance Queries",
        "content": "\r\nDescription\r\n\r\nFarmer John's cows refused to run in his marathon since he chose a path much too long for their leisurely lifestyle. He therefore wants to find a path of a more reasonable length. The input to this problem consists of the same input as in \"Navigation Nightmare\",followed by a line containing a single integer K, followed by K \"distance queries\". Each distance query is a line of input containing two integers, giving the numbers of two farms between which FJ is interested in computing distance (measured in the length of the roads along the path between the two farms). Please answer FJ's distance queries as quickly as possible!\r\n!--more--\r\nInput\r\n\r\n\r\nLines 1..1+M: Same format as \"Navigation Nightmare\"\r\nLine 2+M: A single integer, K. 1 &lt;= K &lt;= 10,000\r\nLines 3+M..2+M+K: Each line corresponds to a distance query and contains the indices of two farms.\r\n\r\nOutput\r\n\r\nLines 1..K: For each distance query, output on a single line an integer giving the appropriate distance.\r\n\r\nSample Input\r\n\r\n7 6\r\n1 6 13 E\r\n6 3 9 E\r\n3 5 7 S\r\n4 1 3 N\r\n2 4 20 W\r\n4 7 2 S\r\n3\r\n1 6\r\n1 4\r\n2 6\r\n\r\n\r\nSample Output\r\n13\r\n3\r\n36\r\n\r\nHint\r\nFarms 2 and 6 are 20+3+13=36 apart.\r\n\r\nSource\r\nUSACO 2004 February\r\nbr/\r\n\r\n- -\r\n\r\n无向树求节点距离：dist(u,v)=dist(root,u)+dist(root,v)-2*dist(root,lca(u,v))\r\ntarjan+并查集求LCA。注意可能树不连通。\r\n\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine MP make_pair\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine F first\r\ndefine S second\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clrA(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\ndefine N 40005\r\ndefine M 40005\r\nint n, m;\r\n//Edge Graph\r\nint head[N], pos;\r\nstruct Edge {\r\n    int v, w, nxt;\r\n} e[M &lt;&lt; 1];\r\nvoid initEdge() {\r\n    memset(head, -1, sizeof(head));\r\n    pos = 0;\r\n}\r\nvoid add(int u, int v, int w) {\r\n    e[pos].v = v;\r\n    e[pos].w = w;\r\n    e[pos].nxt = head[u];\r\n    head[u] = pos++;\r\n}\r\n//UnionSet\r\nint p[N];\r\nvoid initUset() {\r\n    for (int i = 0; i &lt;= n; i++)\r\n        p[i] = i;\r\n}\r\nint uFind(int x) {\r\n    return x == p[x] ? p[x] : p[x] = uFind(p[x]);\r\n}\r\nvoid uMerge(int x, int y) { //y合并到x\r\n    int fx = uFind(x);\r\n    int fy = uFind(y);\r\n    if (fx != fy) p[fy] = fx;\r\n}\r\n//tarjan-LCA\r\nint size,bcnt;\r\nint lca[10005];\r\nint vis[N];\r\nint dis[N];\r\nint ans[10005];\r\nvector&lt;pr&lt;int, int&gt; &gt; query[N];\r\nint findRoot() {\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        if (!vis[i]) return i;\r\n    }\r\n    return assert(false),-1;\r\n}\r\nint dfs(int u, int fa) {\r\n    int solved = 0;\r\n    for (int i = head[u]; ~i; i = e[i].nxt) {\r\n        int v = e[i].v;\r\n        if (v == fa) continue;\r\n        dis[v] = dis[u] + e[i].w;\r\n        solved += dfs(v, u);\r\n        if (solved == size) return solved;\r\n        uMerge(u, v);\r\n    }\r\n    vis[u] = bcnt;\r\n    for (int i = 0; i &lt; (int) query[u].size(); i++) {\r\n        int v = queryu.F;\r\n        if (vis[v]==bcnt) {\r\n            solved++;\r\n            lcaquery[u.S] = uFind(v);\r\n            ansquery[u.S] = disu] + dis[v] - 2 * dis[lca[query[u.S]];\r\n        }\r\n    }\r\n    return solved;\r\n}\r\nvoid tarjan() {\r\n    clrA(vis, 0);\r\n    clrA(dis, 0);\r\n    int tot = 0;\r\n    bcnt=0;\r\n    do {\r\n        bcnt++;//从1开始\r\n        tot += dfs(findRoot(), -1);\r\n    } while (tot &lt; size);//图可能不连通\r\n}\r\n\r\nint main() {\r\n    while (~scanf(\"%d%d\", &amp;n, &amp;m)) {\r\n        int u, v, w;\r\n        char c;\r\n        initEdge();\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            scanf(\"%d%d%d %c\", &amp;u, &amp;v, &amp;w, &amp;c);\r\n            add(u, v, w);\r\n            add(v, u, w);\r\n        }\r\n        initUset();\r\n        scanf(\"%d\", &amp;size);\r\n        for (int i = 1; i &lt;= n; i++)\r\n            query[i].clear();\r\n        for (int i = 1; i &lt;= size; i++) {\r\n            scanf(\"%d%d\", &amp;u, &amp;v);\r\n            query[u].push_back(MP(v, i));\r\n            query[v].push_back(MP(u, i));\r\n        }\r\n        tarjan();\r\n        for (int i = 1; i &lt;= size; i++) {\r\n            printf(\"%d\\n\", ans[i]);\r\n        }\r\n    }\r\n}\r\n`\r\n\r\n另外，还可以转化为RMQ问题求解：\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clrA(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\ndefine N 40005\r\ndefine M 40005\r\nint n, m;\r\n//Edge Graph\r\nint head[N], pos;\r\nstruct Edge {\r\n    int v, w, nxt;\r\n} e[M &lt;&lt; 1];\r\nvoid initEdge() {\r\n    memset(head, -1, sizeof(head));\r\n    pos = 0;\r\n}\r\nvoid add(int u, int v, int w) {\r\n    e[pos].v = v;\r\n    e[pos].w = w;\r\n    e[pos].nxt = head[u];\r\n    head[u] = pos++;\r\n}\r\n//RMQ\r\nint dpM20;//dpMi  从j开始的，连续2^i个数字的最值,j从1开始\r\nint lg2[N&lt;&lt;1|1];//等价于 (int)lg2(1.0*m)/lg2(2.0) 若空间不足可以这样写\r\ndefine getLeft(R,L) (R-(L)+1) //输入右端点和长度，返回左端点\r\nvoid initRMQ(int n) {\r\n    lg2[0]=-1;int limit;\r\n    for(int i=1;i&lt;=n;i++) {\r\n        lg2[i]=(i&amp;(i-1))?lg2[i-1]:lg2[i-1]+1;\r\n    }\r\n    for(int i=1;i&lt;=lg2[n];i++){\r\n        limit=getLeft(n,1&lt;&lt;i);\r\n        for(int j=1;j&lt;=limit;j++){\r\n            dpMi=min(dpMi-1,dpMi-1]);\r\n        }\r\n    }\r\n}\r\nint getRMQ(int a,int b) {\r\n    int t=lg2[b-a+1];\r\n    int s1=a;\r\n    int s2=getLeft(b,1&lt;&lt;t);\r\n    //return max(Maxt,Maxt);\r\n    return min(dpMt,dpMt);\r\n}\r\nundef getLeft\r\n//LCA\r\nint dist[N];\r\nint H[N];//节点第一次出现的位置\r\nint E[N&lt;&lt;1|1];//欧拉序列2n+1个\r\nint cnt,depth;\r\nint findRoot(){\r\n    for(int i=1;i&lt;=n;i++)return i;\r\n    return -1;\r\n}\r\nvoid getEuler(int u=findRoot(),int fa=-1){\r\n    int tmp=dpM0=++cnt]=++depth;\r\n    E[tmp]=u;\r\n    for(int i=head[u];~i;i=e[i].nxt){\r\n        int v=e[i].v;\r\n        if(v==fa)continue;\r\n        dist[v]=dist[u]+e[i].w;\r\n        getEuler(v,u);\r\n        dpM0=tmp;\r\n    }\r\n}\r\nvoid initLCA(){\r\n    memset(dist,0,sizeof(dist));\r\n    cnt=depth=0;\r\n    getEuler();\r\n    initRMQ(cnt);\r\n}\r\nint getLCA(int u,int v){\r\n    if(H[u]&gt;H[v])swap(u,v);\r\n    return E[getRMQ(H[u],H[v])];\r\n}\r\nint main() {\r\n    while (~scanf(\"%d%d\", &amp;n, &amp;m)) {\r\n        int u, v, w;\r\n        char c;\r\n        initEdge();\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            scanf(\"%d%d%d %c\", &amp;u, &amp;v, &amp;w, &amp;c);\r\n            add(u, v, w);\r\n            add(v, u, w);\r\n        }\r\n        initLCA();\r\n        scanf(\"%d\",&amp;m);\r\n        while(m--){\r\n            scanf(\"%d%d\",&amp;u,&amp;v);\r\n            printf(\"%d\\n\",dist[u]+dist[v]-2*dist[getLCA(u,v)]);\r\n        }\r\n    }\r\n}\r\n`",
        "tags": [
            "LCA",
            "RMQ",
            "图论",
            "tarjan"
        ]
    },
    {
        "uri": "/post/polymer-2-1-custom-elements",
        "title": "Polymer 2.0 文档笔记(1) Custom Elements",
        "content": "\r\nhttps://www.polymer-project.org/2.0/docs/devguide/custom-elements\r\n\r\nCustom element names. By specification, the custom element's name must start with a lower-case ASCII letter and must contain a dash (-). There's also a short list of prohibited element names that match existing names. For details, see the Custom elements core concepts section in the HTML specification.\r\n\r\n自定义元素的命名规则： 按照规范，自定义元素的命名中必须以一个小写字母开始，必须包含一个连接符（-）\r\n\r\nCustom properties can only be defined in rule-sets that match the html selector or a Polymer custom element. This is a limitation of the Polymer implementation of custom properties.\r\n\r\nPolymer实现方式的局限： 只有html元素或者Polymer自定义元素才能使用自定义CSS属性。(个人感觉虽然shadowDOM原生支持CSS隔离，但是一部分元素能用cssnext一部分元素不能用，割裂感太严重了。)\r\n\r\nPolymer does not currently support extending built-in elements. The custom elements spec provides a mechanism for extending built-in elements, such as button and  input. The spec calls these elements customized built-in elements. Customized built-in elements provide many advantages (for example, being able to take advantage of built-in accessibility features of UI elements like button and input). However, not all browser makers have agreed to support customized built-in elements, so Polymer does not support them at this time.\r\n\r\n因为浏览器厂商的争议，Polymer不支持扩展内建元素。 \r\n\r\n\r\n在生产环境下main document不要定义自定义元素。基于实验目的可以使用 \r\nHTMLImports.whenReady(callback)方法等待所有html import 加载完毕。\r\n\r\n组件生命周期 \r\n标准的几个生命周期回调： \r\n\r\n| Reaction                 | Description                              |\r\n| ------------------------ | ---------------------------------------- |\r\n| constructor              | Called when the element is upgraded (that is, when an element is created, or when a previously-created element becomes defined). |\r\n| connectedCallback        | Called when the element is added to a document. |\r\n| disconnectedCallback     | Called when the element is removed from a document. |\r\n| attributeChangedCallback | Called when any of the element's attributes are changed, appended, removed, or replaced, |\r\n\r\nFor each reaction, the first line of your implementation must be a call to the superclass constructor or reaction.\r\n\r\n开始写自己的回调事件之前都必须先调用super上面的回调。Super.connectedCallback(); \r\n  \r\n\r\nThe constructor can't examine the element's attributes or children, and the constructor can't add attributes or children. \r\n\r\nConstructor函数中不能对DOM进行任何操作。 \r\n\r\nIn general, work should be deferred to connectedCallback as much as possible—especially work involving fetching resources or rendering. However, note that connectedCallback can be called more than once, so any initialization work that is truly one-time will need a guard to prevent it from running twice. \r\nIn general, the constructor should be used to set up initial state and default values, and to set up event listeners and possibly a shadow root. \r\n\r\nhttps://html.spec.whatwg.org/multipage/custom-elements.htmlcustom-element-conformance \r\n\r\nConstructor里面只应该做一些初始化状态、值、绑定事件，建立shadowroot之类的工作。其他工作应该推迟到connectedCallback里面做，但是需要注意的是connectedCallback可能会调用多次。 \r\n\r\n\r\nThe custom elements specification doesn't provide a one-time initialization callback. Polymer provides a readycallback, invoked the first time the element is added to the DOM. \r\n\r\nPolymer提供了一个规范里面没有的回调： Ready， 只在元素第一次加入DOM时候触发。 \r\n\r\n`javascript\r\nready() { \r\n  super.ready(); \r\n  // When possible, use afterNextRender to defer non-critical \r\n  // work until after first paint. \r\n  Polymer.RenderStatus.afterNextRender(this, function() { \r\n    ... \r\n  }); \r\n} \r\n`\r\n\r\nElements have a custom element state that takes one of the following values:  \r\n  \r\n1. uncustomized: The element does not have a valid custom element name. It is either a built-in element (p, input) or an unknown element that cannot become a custom element (nonsense)    \r\n2. undefined: The element has a valid custom element name (such as \"my-element\"), but has not been defined.    \r\n3. custom: The element has a valid custom element name and has been defined and upgraded.    \r\n4. failed: An attempt to upgrade the element failed (for example, because the class was invalid).    \r\n\r\n\r\n元素内部拥有四个状态，我们不能直接获得，但是可以使用:defined伪类来选择\"uncustomized\"和\"custom\"的元素。 \r\n\r\n\r\n\r\n\r\n\r\n自定义元素\r\n\r\nHybrid elements: should continue to use the Polymer DOM APIs, but may require some changes.\r\nLegacy elements: can use the Polymer DOM APIs or the native DOM APIs.\r\nClass-based elements: should use native DOM APIs.\r\n\r\n总共有三种自定义元素：\r\n\r\nHybird element： 主要是为了兼容Polymer 1.x;但 Gesture Events只支持Hybird elements。详见下文。\r\nLegacy element：处于两者之间（没有看出有什么用处）\r\nClass-based element：Polymer 2.0 最常用的自定义元素方式。\r\n\r\n\r\n\r\n Class-based elements\r\n\r\n`javascript\r\n// define the element's class element\r\nclass MyElement extends Polymer.Element {\r\n  // 'is' getter, return the tag name which is lowercased. required.\r\n  static get is(){\r\n    return 'my-element';\r\n  }\r\n  // Define the properties.\r\n  static get properties() {}\r\n  // Element class can define custom element reactions\r\n  constructor() { super(); }\r\n  connectedCallback() {\r\n    super.connectedCallback();\r\n    console.log('my-element created!');\r\n  }\r\n  ready() {\r\n    super.ready();\r\n    this.textContent = 'I\\'m a custom element!';\r\n  }\r\n}\r\n\r\n// Associate the new class with an element name\r\ncustomElements.define(MyElement.is, MyElement);\r\n\r\n// create an instance with createElement:\r\nvar el1 = document.createElement('my-element');\r\n\r\n// ... or with the constructor:\r\nvar el2 = new MyElement();\r\n`\r\n\r\nLegacy elements\r\n\r\n`javascript\r\n// register an element  \r\nMyElement = Polymer({  \r\nis: 'my-element',  \r\n// See below for lifecycle callbacks  \r\ncreated: function() { this.textContent = 'My element!'; }  \r\n});  \r\n// create an instance with createElement:  \r\nvar el1 = document.createElement('my-element'); \r\n// ... or with the constructor: \r\nvar el2 = new MyElement();\r\n`\r\n\r\nLegacy元素的生命周期有着不同的名字：\r\n\r\n| Legacy lifecycle cb | Class-based lifecycle cb    |\r\n| ------------------- | --------------------------- |\r\n| Created           | constructor               |\r\n| Ready             | ready                     |\r\n| Attached          | connectedCallback         |\r\n| Detached          | disconnectedCallback      |\r\n| attributeChanged  | attributedChangedCallback |\r\n\r\n Hybird elements\r\n这种方式主要是为了兼容Polymer 1.x。可以使用Class-based方式改写。详见Gesture Events。\r\n\r\n自定义属性（properties)\r\n自定义属性主要在properties getter中定义。可以直接传一个字符串。也可以传给他们一个Object。\r\nObject需要包含下面几个属性：\r\n type 数据类型 \r\n\r\nType: constructor  \r\nAttribute type, used for deserializing from an attribute. Polymer supports deserializing the following types: Boolean, Date, Number, String, Array and Object. You can add support for other types by overriding the element's  _deserializeValue method. \r\nUnlike 0.5, the property's type is explicit, specified using the type's constructor. Seeattribute deserialization for more information. \r\n\r\nWhen reflecting a property to an attribute or binding a property to an attribute, the property value is serialized to the attribute. \r\nBy default, values are serialized according to value's current type, regardless of the property's type value: \r\n\r\nString No serialization required.  \r\nDate or Number Serialized using toString. \r\nBoolean Results in a non-valued attribute to be either set (true) or removed (false). \r\nArray or Object Serialized using  JSON.stringify. \r\n\r\nArray和Object需要写成JSON的形式，Date需要写成任何符合Date解析形式的String。\r\n\r\n可以重写属性序列化函数： _serializeValue method.\r\n\r\n`javascript\r\n_serializeValue(value) { \r\n  if (value instanceof MyCustomType) { \r\n    return value.toString(); \r\n  }\r\n  return super._serializeValue(value);\r\n} \r\n`\r\n\r\nvalue 默认值\r\n\r\nType: boolean, number, string or function. \r\nDefault value for the property. If value is a function, the function is invoked and the return value is used as the default value of the property. If the default value should be an array or object unique to the instance, create the array or object inside a function. See Configuring default property values for more information\r\n\r\n跟Vue一样，如果一个属性的默认值是以Array或者Object,那么所有该元素的实例的默认值都共享一个变量。如果要使每个元素拥有一份完全独立的拷贝的话，需要在这个值外面包一个函数。  \r\n\r\n`javascript\r\nclass XCustom extends Polymer.Element { \r\nstatic get properties() { \r\n    return { \r\n      mode: { \r\n        type: String, \r\n        value: 'auto' \r\n      }, \r\n      data: { \r\n        type: Object, \r\n        notify: true, \r\n        value: function() { return {}; } \r\n      } \r\n    } \r\n}\r\n`\r\n\r\n\r\n reflectToAttribute\r\n\r\nType: boolean \r\nSet to true to cause the corresponding attribute to be set on the host node when the property value changes. If the property value is Boolean, the attribute is created as a standard HTML boolean attribute (set if true, not set if false). For other property types, the attribute value is a string representation of the property value. Equivalent to reflect in Polymer 0.5. See Reflecting properties to attributes for more information\r\n\r\n值的变化是否同步更新DOM上面的attr \r\n\r\n\r\nFor a Boolean property to be configurable from markup, it must default to false. If it defaults to true, you cannot set it to false from markup, since the presence of the attribute, with or without a value, equates to true. This is the standard behavior for attributes in the web platform.\r\nIf this behavior doesn't fit your use case, you can use a string-valued or number-valued attribute instead. \r\n\r\nBoolean类型的属性只能把默认值设为false，因为标准的HTML属性行为（存在为true，不存在为false）,如果必须把默认值设为true，可以用String或者Number类型属性代替。 \r\n\r\nreadOnly\r\n\r\nType: boolean \r\nIf true, the property can't be set directly by assignment or data binding.\r\n\r\n notify\r\n\r\nType: boolean \r\nIf true, the property is available for two-way data binding. In addition, an event, property-name-changed is fired whenever the property changes\r\n\r\nDOM上面的属性变化是否调用回调（反向绑定）属性this.firstName的变化会触发first-name-changed事件。这些事件被用在了双向绑定系统，在外部代码里面我们可以直接使用addEventListener。 \r\n有点像Java里面的约定大于配置的思想，这样能使代码变得简单易懂\r\n\r\ncomputed\r\n\r\nType: string \r\nThe value is interpreted as a method name and argument list. The method is invoked to calculate the value whenever any of the argument values changes. Computed properties are always read-only. See Computed properties for more information\r\n\r\n\r\n传入一个包含方法名和参数列表的字符串，参数必须readOnly，将该方法调用参数运行的结果作为该项的值\r\n\r\n\r\n observer\r\n\r\nType: string \r\nThe value is interpreted as a method name to be invoked when the property value changes. Note that unlike in 0.5, property change handlers must be registered \r\nexplicitly. The propertyNameChanged method will not be invoked automatically. See Property change callbacks (observers) for more information\r\n\r\n传入一个方法名称，当值发生变化时自动执行该方法 \r\n\r\n\r\n其他\r\n\r\n隐式声明属性: if you add it to a data binding or add it as a dependency of an observer, computed property, or computed binding. \r\nPriavte和Protected属性：分别用_prop和prop表示。\r\n\r\n\r\n",
        "tags": [
            "Polymer"
        ]
    },
    {
        "uri": "/post/polymer-2-2-shadowdom",
        "title": "Polymer 2.0 文档笔记(2) ShadowDOM",
        "content": "\r\nShadowDOM API\r\n`javascript\r\nvar div = document.createElement('div'); \r\nvar shadowRoot = div.attachShadow({mode: 'open'}); \r\nshadowRoot.innerHTML = 'h1Hello Shadow DOM/h1';\r\n`\r\n\r\n\r\n ShadowDOM Composition\r\n主要概念： \r\n\r\nLightDOM: 元素的实际子孙节点，浏览器不会对LightDOM做任何的修改和移动。但是渲染的时候会渲染到相对于的slot节点之下，如果找不到对应的slot节点，则不会渲染。\r\nShadowDOM: 不解释。。。 \r\nSlot:  slot标签是LightDOM插入到ShadowDOM中的标记。可以设置name属性来匹配对应的LightDOM。Slot标签不会渲染，但是还是会存在（即能够参与事件传递）。另外如果一个LightDOM找不到匹配的slot插入点，则改LightDOM也不会被渲染。 \r\nFlatterned Tree: LightDOM通过ShadowDOM里面的slot标记合并在一起（flattern）的抽象的DOM树（devTools中不可见），是最后浏览器实际用来渲染的DOM树。 \r\n\r\n需要注意的是：\r\n\r\nSlots can only be selected explicitly, by slot name. It's impossible to select content implicitly, based on a tag name or an arbitrary selector like :not(.header).\r\n\r\nslot只能用slot name来区分、选中。不能用其他任意的css选择器。\r\n\r\n各个slot之间的区域是互斥的，而且 只能选择top-level元素 (包括后面的::slotted(selector)选择器)。\r\n`html\r\n!-- shadow DOM v1 template --\r\ntemplate\r\n  <!-- this slot gets any top-level nodes that don't have slot\r\n       attributes. --\r\n  slot/slot\r\n  <!-- the following insertion point gets any top-level nodes that have\r\n       slot=\"special\". --\r\n  slot name=\"special\"/slot\r\n  <!-- top-level nodes that have slot attributes with other values\r\n       don't get distributed at all. --\r\n/template\r\n`\r\n\r\nFallback content\r\n实际上就是可以在模版的slot里面写东西，作为一个默认值\r\n\r\n Mulit-level distribution\r\n多级slot嵌套。flatterning的时候规则是从外向里， 因此父节点的slot下面的lightDOM会渲染在子节点的LightDOM之下。\r\n\r\n\r\nSlot APIs && Observe added and removed children \r\n \r\nHTMLElement.assignedSlot\r\nHTMLSlotElement.assignedNodes \r\nHTMLSlotElement.slotchange(event) \r\nPolymer.FlattenedNodesObserver \r\nPolymer.FlattenedNodesObserver.getFlattenedNodes(node)\r\nnew Polymer.FlattenedNodesObserver(this.$.slot,(info)={})\r\n\r\n详情参考https://www.polymer-project.org/2.0/docs/devguide/shadow-dom  \r\n\r\n\r\n Shadow DOM polyfills \r\n因为shadowDOM不是每个浏览器都支持，所以使用了webcomponents.js中的shadyDOM和shadyCSS两个polyfills。 \r\n \r\nHow the polyfills work \r\n \r\nThe polyfills use a combination of techniques to emulate shadow DOM: \r\nShady DOM: Maintains the logical divisions of shadow tree and descendant tree internally, so children added to the light DOM or shadow DOM render correctly. Patches DOM APIs on affected elements in order to emulate the native shadow DOM APIs. \r\nShady CSS: Provides style encapsulation by adding classes to shadow DOM children and rewriting style rules so that they apply to the correct scope. \r\n\r\n ShadyDOM\r\nShadyDOM主要原理是patch原生DOM API来提供跟native shadowDOM一致的接口。在内存中维护了一个保存LightDOM的children树和一个保存ShadowDOM的ShadowRoot树。但是实际上元素下面就是一颗渲染好的flatterned树。因为这个是就是实际上的用来渲染的树，所以不存在slot，因此shadyDOM polyfills方案里面的slot元素不参与事件传递。 \r\n \r\nShadyCSS \r\nShadyCSS主要提供了原生ShadowDOM规则的支持和两个cssnext特性：CSS custom properties 和 custom property mixins. \r\nScoped CSS特性的实现原理跟Vue相似：对元素的ShadowDOM添加class，并重写CSS的匹配规则。 \r\n\r\n\r\n ShadowDOM styling\r\nShadowDOM样式三大原则： \r\n\r\n外层的样式不会对内层样式进行匹配。 \r\n内层样式不会影响外层样式。 \r\n可继承的css属性（例如：color）等，内层可以照样继承自外层。 \r\n\r\n两个特殊伪类： \r\n选择ShadowDOM的根节点节点:host/:host(selector)\r\n`html\r\nshadow-root\r\n  style\r\n    /* custom elements default to display: inline */\r\n    :host {\r\n      display: block;\r\n    }\r\n    /* set a special background when the host element\r\n       has the .warning class */\r\n    :host(.warning) {\r\n      background-color: red;\r\n    }\r\n  /style\r\n`\r\n    \r\n选择分布式节点——::slotted()\r\n  slotted()选择器右边不能写任何其他选择器。\r\n  slotted(selector) 里面的selector只能是简单选择器，并且只能选择顶级元素。\r\n  slotted(*) 选择默认的LightDOM(不包含有name值的slot)\r\n  slotted(slot=tkw) 选择name为tkw的LightDOM\r\n\r\n  `html\r\n  dom-module\r\n  template\r\n    style\r\n      ::slotted(img){ \r\n        border-radius: 103%;\r\n      }\r\n    /style\r\n    divslot/slot/div\r\n  /template\r\n  script\r\n    // define the element's class element\r\n    class XFoo extends Polymer.Element {\r\n      // 'is' getter, return the tag name which is lowercased. required.\r\n      static get is(){\r\n        return 'x-foo';\r\n      }\r\n      // Define the properties.\r\n      static get properties() {}\r\n      // Element class can define custom element reactions\r\n      constructor() { super(); }\r\n      connectedCallback() {\r\n        super.connectedCallback();\r\n        console.log('x-foo created!');\r\n      }\r\n    }\r\n    \r\n    window.customElements.define(XFoo.is, XFoo);\r\n  /script\r\n  /dom-module\r\n\r\n  x-foo\r\n    h1A logo/h1\r\n    img /\r\n  /x-foo\r\n  `\r\n\r\n Share styles between elements\r\n\r\n`html\r\ndom-module id=\"my-style-module\" \r\n  template \r\n    style \r\n      !-- Styles to share go here! -- \r\n    /style \r\n  /template \r\n/dom-module\r\n\r\n!-- another element --\r\ndom-module id=\"new-element\" \r\n  template \r\n    style include=\"my-style-module\" \r\n      !-- Any additional styles go here -- \r\n    /style \r\n    !-- The rest of your element template goes here -- \r\n  /template \r\n/dom-module\r\n`\r\ncustom-style\r\n兼容性写法，使用custom-style标签包围main document里面的全局style能避免在不支持shadowDOM v1规范的浏览器中全局css规则继续在shadowDOM中生效。\r\n注意是避免CSS规则生效，而不是避免CSS样式的继承\r\ncustom-style元素不包含在Polymer中，需要引入：\r\n`html\r\nlink rel=\"import\" href=\"components/polymer/lib/elements/custom-style.html\"\r\n`\r\n\r\n CSS custom properties\r\n主要是提供一个支持两个CSS Next语法的扩展版本：\r\ncustom properties & var()\r\n可以通过——customvar形式定义变量，然后通过var(--customvar,[defaultvar])取值。\r\n通过这个特性我们可以暴露出一些可配置的变量，然后供组件外部的父元素进行自定义。\r\n与cssnext规范不同的是，cssnext的变量定义必须写在:root{}中，而Polymer则是不能在LightDOM中使用。\r\n\r\n`css\r\np {\r\n  color: var(--paper-red-500);\r\n}\r\npaper-checkbox {\r\n  --paper-checkbox-checked-color: var(--paper-red-500);\r\n}\r\n`\r\n custom properties set & @apply\r\nPolymer默认不支持自定义属性集合，需要手动引入：\r\n`html\r\n!-- import CSS mixins polyfill --\r\nlink rel=\"import\" href=\"/bower_components/shadycss/apply-shim.html\"\r\n`\r\n相当于cssnext对应的语法，但是同样可以在任何css Rule下使用。\r\n`html\r\ndom-module id=\"my-element\" \r\n  template \r\n    style \r\n      /* Apply custom theme to toolbars */ \r\n      :host { \r\n        --my-toolbar-theme: { \r\n          background-color: green; \r\n          border-radius: 4px; \r\n          border: 1px solid gray; \r\n        }; \r\n        --my-toolbar-title-theme: { \r\n          color: green; \r\n        }; \r\n      } \r\n      /* Make only toolbars with the .warning class red and bold */ \r\n      .warning { \r\n        --my-toolbar-title-theme: { \r\n          color: red; \r\n          font-weight: bold; \r\n        }; \r\n      } \r\n    /style \r\n    my-toolbar title=\"This one is green.\"/my-toolbar \r\n    my-toolbar title=\"This one is green too.\"/my-toolbar \r\n    my-toolbar class=\"warning\" title=\"This one is red.\"/my-toolbar \r\n  /template \r\n  script \r\n    class MyElement extends Polymer.Element { \r\n      static get is() { \r\n        return \"my-element\"; \r\n      } \r\n    } \r\n    customElements.define(MyElement.is, MyElement); \r\n  /script \r\n/dom-module \r\n \r\ndom-module id=\"my-toolbar\" \r\n  template \r\n    style \r\n      :host { \r\n        padding: 4px; \r\n        background-color: gray; \r\n        /* apply a mixin */ \r\n        @apply --my-toolbar-theme; \r\n      } \r\n      .title { \r\n        @apply --my-toolbar-title-theme; \r\n      } \r\n    /style \r\n    span class=\"title\"{{title}}/span \r\n  /template \r\n  ... \r\n/dom-module\r\n`\r\nCSS Custom Property API\r\n\r\n updateStyles\r\n动态更改css自定义属性的值。\r\n`html\r\ndom-module id=\"x-custom\"\r\n  template\r\n    style\r\n      :host {\r\n        --my-toolbar-color: red;\r\n      }\r\n    /style\r\n    my-toolbarMy awesome app/my-toolbar\r\n    button on-tap=\"changeTheme\"Change theme/button\r\n  /template\r\n  script\r\n    class XCustom extends Polymer.Element {\r\n      static get is() {\r\n        return \"x-custom\";\r\n      }\r\n      static get changeTheme() {\r\n        return function() {\r\n        this.updateStyles({\r\n          '--my-toolbar-color': 'blue',\r\n        });\r\n      }\r\n    }\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n/dom-module\r\n`\r\n注意当外层元素或者被继承元素里面已经定义了一个变量，那么当前再定义这个变量是无效的，需要手动调用该方法。这个行为类似于Less\r\n\r\n\r\ngetComputedStyle(ShadyCSS.getComputedStyle)\r\n获得当前自定义属性的值(需要区分原生和Polyfill)\r\n`javascript\r\nif (ShadyCSS) { \r\n  style = ShadyCSS.getComputedStyleValue('--something'); \r\n} else { \r\n  style = getComputedStyle(this, '--something'); \r\n} \r\n`\r\n\r\n DOM Templating\r\n\r\nBy default, adding a DOM template to an element causes Polymer to create a shadow root for the element and clone the template into the shadow tree. \r\n\r\nDOMTemplate是通过clone操作添加到shadow tree里面去的。 有三种方式定义一个DOM Template： \r\ntemplate标签 \r\n直接将模板写在template标签里面, 是最直接的方式、最常见的方式。 \r\n`html\r\ndom-module id=\"x-foo\" \r\ntemplateI am x-foo!/template \r\nscript \r\n    class XFoo extends Polymer.Element { \r\n      static get is() { return  'x-foo' } \r\n    } \r\n    customElements.define(XFoo.is, XFoo); \r\n/script \r\n/dom-module \r\n`\r\n String template \r\n字符串模板\r\n`javascript\r\nclass MyElement extends Polymer.Element { \r\n \r\nstatic get template() { \r\n    return `style:host { color: blue; }/style \r\n       h2String template/h2 \r\n       divI've got a string template!/div` \r\n  } \r\n} \r\ncustomElements.define('my-element', MyElement); \r\n`\r\nRetrieve or generate your own template element \r\n通过继承或手动实现template getter获得模板.\r\n注意：\r\n不要对父类的template直接修改，应该先拷贝一份出来。 \r\n如果需要做一些耗资源的操作，应该对你修改的template进行缓存，以免重复调用。 \r\n\r\n\r\n`javascript\r\n(function() { \r\n  let memoizedTemplate; \r\n \r\nclass MyExtension extends MySuperClass { \r\n    static get template() { \r\n      if (!memoizedTemplate) { \r\n        // create a clone of superclass template (true = \"deep\" clone) \r\n        memoizedTemplate = MySuperClass.template.cloneNode(true); \r\n        // add a node to the template. \r\n        let div = document.createElement('div'); \r\n        div.textContent = 'Hello from an extended template.' \r\n        memoizedTemplate.content.appendChild(div); \r\n      } \r\n      return memoizedTemplate; \r\n    } \r\n  } \r\n \r\n})(); \r\n`  \r\n URLs in template\r\n默认对于所有从其他文件里面引入的组件里面元素所包含的链接Polymer是不做处理的，所有的相对路径的资源最后都是相对于主文档（main document）的路径。 \r\n但是我们可以使用下面两个特殊的标记\r\n\r\nimportPath \r\nA static getter on the element class that defaults to the element HTML import document URL and is overridable. It may be useful to override importPath when an element's template is not retrieved from a dom-module or the element is not defined using an HTML import. \r\n \r\n\r\n一个静态getter函数，默认指向该元素被HTML import时候的URL，也可以被重写。 \r\n\r\n rootPath\r\nAn instance property set to the value of Polymer.rootPath which is globally settable and defaults to the main document URL. It may be useful to set Polymer.rootPath to provide a stable application mount path when using client side routing.\r\n\r\n一个实例化的属性，值被设置为Polymer.rootPath。代表着主文档(main document)的URL。 \r\n\r\nRelative URLs in styles are automatically re-written to be relative to the importPath property. Any URLs outside of a style element should be bound using importPath or rootPath where appropriate.\r\n \r\n所有style标签里面的URL全部被重写为相对于importPath的路径。除此之外，都需要自己手动添加合适的前缀： \r\n`html\r\nimg src$=\"[[importPath]]checked.jpg\" \r\n \r\na href$=\"[[rootPath]]users/profile\"View profile/a\r\n`\r\n\r\nStatic node map \r\nPolymer builds a static map of node IDs when the element initializes its DOM template, to provide convenient access to frequently used nodes without the need to query for them manually. Any node specified in the element's template with an id is stored on the this.$ hash by id. \r\n The this.$ hash is created when the shadow DOM is initialized. In the ready callback, you must call super.ready() before accessing this.$. \r\n \r\n这个主要是Polymer提供的一个可以快速访问DOM节点的方式。可以通过this.$[id]来获取拥有对应id的元素/自定义元素。  \r\n相当于document.getElementById的升级版类似于react中的this.refs   \r\nthis.$接口只能在ready回调函数的super.ready()之后被调用。   \r\n动态创建的节点（dom-repeat\\ dom-if）并不包含在this.$集合里，但是还是可以用标准的querySelector方法获取。    \r\n\r\n\r\n`html\r\ndom-module id=\"x-custom\" \r\n \r\ntemplate \r\n    Hello World from span id=\"name\"/span! \r\n  /template \r\n \r\nscript \r\n    class MyElement extends Polymer.Element { \r\n      static get is() { return  'x-custom' } \r\n      ready() { \r\n        super.ready(); \r\n        this.$.name.textContent = this.tagName; \r\n      } \r\n    } \r\n  /script \r\n \r\n/dom-module\r\n`\r\n\r\n\r\n",
        "tags": [
            "Polymer"
        ]
    },
    {
        "uri": "/post/polymer-2-3-events",
        "title": "Polymer 2.0 文档笔记(3) Events",
        "content": "Normal Events\r\n\r\nPolymer elements can use the standard DOM APIs for creating, dispatching, and listening for events. \r\nPolymer also provides annotated event listeners, which allow you to specify event listeners declaratively as part of the element's DOM template. \r\n\r\n Add annotated event listeners \r\n这个其实就是在标签上使用on-event属性。 \r\n`html\r\ndom-module id=\"x-custom\" \r\n  template \r\n    button on-click=\"handleClick\"Kick Me/button \r\n  /template \r\n  script \r\n    class XCustom extends Polymer.Element { \r\n \r\nstatic get is() {return 'x-custom'} \r\n \r\nhandleClick() { \r\nconsole.log('Ow!'); \r\n} \r\n} \r\ncustomElements.define(XCustom.is, XCustom); \r\n     /script \r\n/dom-module \r\n`\r\n需要注意的有： \r\n\r\n如果添加了手势事件则应当使用on-tap事件代替on-click事件，提供更好的移动浏览器支持。 \r\n因为html属性的限制，所有的事件名称都将转化为小写字母。(To avoid confusion, always use lowercase event names. )\r\n \r\nAdd and remove listeners imperatively \r\n直接使用原生的addEventListener和removeEventListener \r\n \r\n Fire custom events \r\n直接使用原生的CustomEvent和dispatchEvent \r\n \r\nEvent Retargeting\r\n\r\n为了保持ShadowDOM的隐蔽性。元素内部ShadowDOM触发的一些事件在网上传播时会将target重定向到当前元素。 \r\nevent.composedPath() : 包含事件传递过程中所经过的nodes路径列表。  \r\n\r\n自定义的事件默认无法穿透ShadowDOM边界。可以如下设置： \r\n`javascript\r\nvar event = new CustomEvent('my-event', {bubbles: true, composed: true});\r\n`\r\n\r\n Gesture Events \r\n \r\n手势事件的支持是基于Legacy Element的，如果使用Polymer2的class风格定义需要使用mixin:Polymer.GestureEventListeners\r\n`html\r\nlink rel=\"import\" href=\"polymer/lib/mixins/gesture-event-listeners.html\" \r\n \r\nscript \r\n    class TestEvent extends Polymer.GestureEventListeners(Polymer.Element) { \r\n      ... \r\n/script \r\n`\r\n注册事件也有两种方式： \r\n支持on-event形式的声明方式 \r\n显示定义的方式：Polymer.Gestures.addListener(this, 'tap', e = this.tapHandler(e)); \r\n \r\n \r\n包含以下几种手势事件，包含在e.detail中。 \r\n\r\ndown—finger/button went down \r\n  x—clientX coordinate for event \r\n  y—clientY coordinate for event \r\n  sourceEvent—the original DOM event that caused the down action \r\nup—finger/button went up \r\n  x—clientX coordinate for event \r\n  y—clientY coordinate for event \r\n  sourceEvent—the original DOM event that caused the up action \r\ntap—down & up occurred \r\n  x—clientX coordinate for event \r\n  y—clientY coordinate for event \r\n  sourceEvent—the original DOM event that caused the tap action \r\ntrack—moving while finger/button is down \r\n  state—a string indicating the tracking state: \r\n    start—fired when tracking is first detected (finger/button down and moved past a pre-set distance threshold) \r\n    track—fired while tracking \r\n    end—fired when tracking ends \r\n  x—clientX coordinate for event \r\n  y—clientY coordinate for event \r\n  dx—change in pixels horizontally since the first track event \r\n  dy—change in pixels vertically since the first track event \r\n  ddx—change in pixels horizontally since last track event \r\n  ddy—change in pixels vertically since last track event \r\n  hover()-a function that may be called to determine the element currently being hovered ",
        "tags": [
            "Polymer"
        ]
    },
    {
        "uri": "/post/polymer-2-4-data-system",
        "title": "Polymer 2.0 文档笔记(4) Data System",
        "content": "\r\nPolymer提供观察函数、计算属性、数据绑定三大模型功能：\r\n\r\n- Observers Callbacks invoked when data changes. \r\n- Computed properties Virtual properties computed based on other properties, and recomputed when the input data changes. \r\n- Data bindings Annotations that update the properties, attributes, or text content of a DOM node when data changes. \r\n\r\n\r\n `html\r\ndom-module id=\"name-card\" \r\n  template \r\n    div[[name.first]] [[name.last]]/div \r\n  /template \r\n  script \r\n    class NameCard extends Polymer.Element { \r\n      static get is() { return \"name-card\"; } \r\n      constructor() { \r\n        super(); \r\n        this.name = {first: 'Kai', last: 'Li'}; \r\n      } \r\n    } \r\n    customElements.define(NameCard.is, NameCard); \r\n  /script \r\n/dom-module \r\n `\r\n\r\nObservable Change\r\n \r\nThe data system is based on paths, not objects, where a path represents a property or subproperty relative to the host element. \r\n\r\nPolymer的数据系统是基于数据的 路径 之上的。并不是实际的对象。\r\n\r\n可观察到的变化指的是Polymer里面存在一个相关的路径指向这个数据的变化。因此，直接改变一个object、array等引用对象不会被观察到。\r\n`javascript\r\nthis.address.street = 'Elm Street'\r\n`\r\n改变address.street并不能被address上的观察器捕捉到变化\r\n\r\n Mutating objects and arrays observably\r\n使用Polymer提供的方法：\r\n`javascript\r\n// 改变object\r\nthis.set('address.street','Half Moon Street') \r\n// 改变array\r\nthis.set('users.3',{name:'Hawking'})\r\nthis.push('users',{name: 'Maturin'}) \r\nthis.pop('users')\r\nthis.unshift('users',{name: 'Martin'})\r\nthis.shift('users')\r\nthis.splice('users',3,1,{name:'Hawking'})\r\n\r\n// 批量更新\r\nthis.setProperties({item:'Orange', count:12},true) //setReadOnly:true 代表需要设置ready-only的属性\r\n//延迟统一更新\r\nthis.notifyPath('address.street') \r\nthis.notifySplices('users') //only array\r\n\r\n// 获得路径代表的属性值\r\nvar value = this.get('address.street') \r\n //获得users[2]的值\r\nvar item = this.get(['users',2])\r\n`\r\n\r\nPolymer performs dirty checking for objects and arrays using object equality. It doesn't produce any property effects if the value at the specified path hasn't changed.\r\n\r\nnotifyPath方式需要提供具体属性的路径，而不应该是Object或Array，因为Polymer直接使用数据引用地址进行比较。如果一定需要观察它们，Polymer提供了三种解决方案：\r\n\r\n使用Immutable之类的库，或者每次改变Object和Array里面的值的时候都先克隆出一个副本，在克隆的副本上修改然后把路径指向克隆副本。\r\n使用mixin Polymer.MutableData可以禁止Polymer的对object和array的脏检查(dirty check)\r\n使用mixin Polymer.OptionalMutableData可以在标签上添加一个bool属性mutable，代表是否对object或array开启脏检测\r\n\r\nData Paths\r\nA data path is a series of path segments. In most cases, each path segment is a property name. The data APIs accept two kinds of paths:\r\n- A string, with path segments separated by dots.\r\n- An array of strings, where each array element is either a path segment or a dotted path.\r\n\r\n数据路径可以是一个路径字符串，也可以是一个包含路径字符串的数组，比如下面三行全部代表同一个路径：\r\n`javascript\r\n\"one.two.three\"\r\n[\"one\", \"two\", \"three\"]\r\n[\"one.two\", \"three\"]\r\n`\r\n\r\n\r\n\r\n Polymer doesn't automatically know that these properties refer to the same object.address-card makes a change to the object, no property effects are invoked on user-profile\r\n For data changes to flow from one element to another, the elements must be connected with a data binding.\r\n\r\nPolymer是以路径来监听数据变化的。所以，就算两个路径实际上都指向同一个对象，他俩也不会联动。需要对这两个路径进行链接操作。\r\n\r\n Linking paths with data bindings\r\n\r\ndata binding is the only way to link paths on different elements\r\n\r\n`html\r\ndom-module id=\"user-profile\"\r\n  template\r\n    …\r\n    <address-card\r\n        address=\"{{primaryAddress}}\"/address-card\r\n  /template\r\n  …\r\n/dom-module\r\n`\r\n链接两个路径之后的示意图：\r\n\r\n\r\nThe user-profile element has a property primaryAddress that refers to a JavaScript object.\r\nThe address-card element has a property address that refers to the same object.\r\nThe data binding connects the path \"primaryAddress\" on user-profile to the path \"address\" on address-card\r\n\r\n\r\nData binding scope\r\nPaths are relative to the current data binding scope.\r\nThe topmost scope for any element is the element's properties. Certain data binding helper elements (like template repeaters) introduce new, nested scopes.\r\nFor observers and computed properties, the scope is always the element's properties.\r\n\r\n上面所说的路径都是相对于当前数据绑定(data-binding scope)定的。\r\n最外层的域就是当前元素的本身(this)，但一些数据绑定辅助元素(比如: template repeaters)可以创建新的子域。\r\n观察函数(observers)和计算属性computed properties的域永远都是当前元素本身(this)\r\n\r\n Special paths\r\n通配路径(Wildcard paths)-可以使用通配符`来表示当前路径下的所有子路径的任何变化。比如users指向一个数组,users.`代表该数组的所有变化\r\nsplices- 可以用在数组路径后面，代表数组任何添加、删除的变化\r\n数组路径后面接下标代表数组里面对应的项，比如users.12\r\n\r\n注意： \r\n\r\n通配符只能用在observers、computed properties里面的路径中，不能用在数据绑定里\r\n观察splices路径时，事件参数中只提供当前数组发生变化的元素组成的子数组，所以在一般情况下通配符路径比splices路径要实用\r\n\r\n\r\nTwo paths referencing the same object\r\n如果两条路径都指向同一个对象,如下图,需要使用linkPaths方法将它们关联起来。\r\n\r\n注意： \r\n\r\n两条路径必须在同一个data scope下\r\n如果需要接触两条路径的关联，使用unlinkPaths, 该函数只接受linkPaths调用时的第一条路径\r\n\r\n\r\n\r\n\r\n Data flow\r\nPolymer implements the mediator pattern, where a host element manages data flow between itself and its local DOM nodes.\r\nWhen two elements are connected with a data binding, data changes can flow downward, from host to target, upward, from target to host, or both ways.\r\nWhen two elements in the local DOM are bound to the same property data appears to flow from one element to the other, but this flow is mediated by the host. A change made by one element propagates up to the host, then the host propagates the change down to the second element.\r\n\r\n\r\nPolymer的数据流是一个中间人模型。任何存在数据绑定的两个元素直接的数据流都不是表面上的直接传递的，而是先向上传递(upward)到host元素再向下传递(downward)到目标元素。\r\n\r\n Data flow is synchronous. When your code makes an observable change, all of the data flow and property effects from that change occur before the next line of your JavaScript is executed, unless an element explicitly defers action (for example, by calling an asynchronous method).\r\n\r\nPolymer的数据传递是同步的，除非调用一个外部异步函数\r\n\r\nHow data flow is controlled\r\n数据流的方向主要由两个地方控制：数据绑定方式和属性配置项。\r\n\r\n数据绑定主要有两种方式：\r\nAutomatic ：双向绑定，包括向上(upward,target to host)和向下(downward.host to target),使用 \\{\\{ \\}\\}\r\n    `html\r\n    my-input value=\"{{name}}\"/my-input\r\n    `\r\n\r\nOne-way :单向绑定，仅向下(downward.host to target)，使用[[ ]]\r\n    `html\r\n    name-tag name=\"[[name]]\"/name-tag\r\n    `\r\n属性配置项具体有两项：\r\nnotify 允许数据向上(upward,target to host)传递，默认为false\r\nreadOnly 禁止数据向下(downward.host to target)传递到当前组件，默认false\r\n\r\n属性配置实例：\r\n\r\n`js\r\nproperties: {\r\n  // default prop, read/write, non-notifying.\r\n  basicProp: {\r\n  },\r\n  // read/write, notifying\r\n  notifyingProp: {\r\n    notify: true\r\n  },\r\n  // read-only, notifying\r\n  fancyProp: {\r\n    readOnly: true,\r\n    notify: true\r\n  }\r\n}\r\n`\r\n注意：\r\n当使用单向绑定的时候，notify配置项无效。\r\n当单向绑定且readOnly:true时，将没有任何数据流\r\n\r\n\r\n\r\n**Property configuration only affects the property itself, not\r\nsubproperties**. In particular, binding a property that's an object or array creates shared data\r\nbetween the host and target element. There's no way to prevent either element from mutating a shared\r\nobject or array.\r\n\r\n属性配置不能继承\r\n\r\n\r\n\r\n Data flow examples\r\n参考:Data flow examples\r\n\r\n\r\n\r\n\r\nUpward and downward data flow\r\n\r\nSince the host element manages data flow, it can directly interact with the target element. The host\r\npropagates data downward by setting the target element’s properties or invoking its methods.\r\n\r\nhost元素可以直接通过设置target元素属性或调用回调函数等方法将数据向下传递给target元素\r\n\r\n\r\n\r\nPolymer elements use events to propagate data upward. The target element fires a non-bubbling event\r\nwhen an observable change occurs.\r\n\r\n当数据是双向绑定的时候，target元素通过触发一个non-bubbling的change事件来将数据传递给监听这个事件的host元素，host元素监听到事件后对数据变化做出响应改变数据绑定模型（可能影响相邻元素）并触发另外一个change事件向上传播。\r\n\r\n当数据是单向绑定的时候，host元素不会监听target元素的change事件，因此数据无法向上传递。\r\n\r\n\r\n\r\n\r\n\r\n Data flow for objects and arrays\r\n\r\nFor object and array properties, data flow is a little more complicated. An object or array can be\r\nreferenced by multiple elements, and there's no way to prevent one element from mutating a shared\r\narray or changing a subproperty of an object.\r\nAs a result, Polymer treats the contents of arrays and objects as always being available for two-\r\nway binding. That is:\r\n\r\n*   Data updates always flow downwards, even if the target property is marked read-only.\r\n*   Change events for upward data flow are always fired, even if the target property is not marked\r\n    as notifying.\r\n\r\nSince one-way binding annotations don't create an event listener, they prevent these change\r\nnotifications from being propagated to the host element.\r\n\r\n对于objects和arrays绑定的数据流非常复杂，不得已Polymer将忽略关于它们所有的readyOnly和notify配置项，并将它们hardcode为true，单项绑定和双向绑定不受影响。\r\n\r\nChange notification events \r\n当一个元素某路径比如property发生变化，则会响应的触发一个property-changed的通知事件。\r\n事件内容根据路径类型相关：\r\n\r\n属性变化： 新值将储存detail.value中\r\n子属性变化：子属性的路径将会储存在detail.path中，新值将会储存在detail.value中。\r\n数组变化：变化路径将会储存在detail.path中(比如： myArray.splices)，新值将会被储存在detail.value中。\r\n\r\n\r\nDon't stop propagation on change notification events. To avoid creating and discarding\r\nevent objects, Polymer uses cached event objects for change notifications. Calling stopPropagation\r\non a change notification event prevents all future events for that property. Change notification\r\nevents don't bubble, so there should be no reason to stop propagation.\r\n\r\n注意： 不要在通知事件里面使用stopPropagation\r\n\r\n\r\n Custom change notification events\r\n\r\n一些Native元素比如input并不存在变化通知事件，因此也不能将数据向上传递。可以通过下面的方式手动自定义一个变化通知事件：\r\n\r\n`html\r\ninput value=\"{{firstName::change}}\"\r\n`\r\n\r\nIn this example, the firstName property is bound to the input's value property. Whenever the\r\ninput element fires its change event, Polymer updates the firstName property to match the input\r\nvalue, and invokes any associated property effects. The contents of the event aren't important.\r\n\r\nThis technique is especially useful for native input elements, but can be used to provide two-way\r\nbinding for any non-Polymer component that exposes a property and fires an event when the property\r\nchanges.\r\n\r\n\r\n\r\nProperty effects\r\n当属性变化的时候，下面的任务会依次执行：\r\n\r\n重写计算受到影响的属性的值 - 此步将会更新计算属性(computed properties)\r\n更新数据绑定\r\n更新host元素上面的html属性\r\n执行观察事件observers\r\n触发变化通知事件\r\n\r\n\r\n\r\n",
        "tags": [
            "Polymer"
        ]
    },
    {
        "uri": "/post/polymer-2-5-observers-and-computed-properties",
        "title": "Polymer 2.0 文档笔记(5) Observers && Computed Properites",
        "content": "有两种监听器：\r\n\r\n简单监听器，只能监听单一的property\r\n复杂监听器：可以监听一到多个property\r\n\r\n每个监听器都有一个或多个 依赖 ，当依赖发生可监听的变化是，监听方法就会被调用。\r\n\r\n\r\nComputed properties are virtual properties based on one or more pieces of the element's data. A\r\ncomputed property is generated by a computing function—essentially, a complex observer that returns\r\na value.\r\n\r\n计算属性顾名思义，是由一个返回某个值的计算函数算出来的属性。\r\n\r\n\r\nObservers and element initialization\r\n只有当元素初始值加载完毕并且至少有一个依赖的属性被定义(undefined = somevalue)，监听器才会被调用。\r\n\r\n\r\n Observers are synchronous\r\n\r\n监听器的执行也是同步的\r\n如果监听器调用比较频繁，影响效率，可以使用Polymer.Async库来将它放到异步任务队列里面去。\r\nPolymer不保证异步执行的监听器所传的参数是否是最新的\r\n\r\n\r\nSimple observers\r\n\r\n简单监听器需要在properties中需要监听的property里面注册。监听函数里面不能依赖其他任何property\r\n\r\n Simple observers are fired the first time the property becomes defined (!= undefined), and on\r\nevery change thereafter, _even if the property becomes undefined._\r\n\r\n简单监听器第一次触发在property被定义后(undefined = somevalue)，在此之后，任何property变化(包括重新变回undefined)都会被调用。\r\n\r\nSimple observers only fire when the property itself changes. They don't fire on subproperty\r\nchanges, or array mutation.\r\n\r\n简单监听器只会响应当前property的可观察变化(observable changes)\r\n\r\nYou specify an observer method by name. The host element must have a method with that name.\r\n\r\n简单监听器的定义和实现(函数本身)必须一一对应,简单监听器的实现可以在当前class里面也可以继承自superclass也可以添加自mixin。\r\n\r\n\r\nThe observer method receives the new and old values of the property as arguments.\r\n\r\n简单监听器接受两个参数： oldValue,newValue\r\n\r\n Observe a property\r\n\r\n`javascript\r\nclass XCustom extends Polymer.Element {\r\n\r\n  static get is() {return 'x-custom'; }\r\n\r\n  static get properties() {\r\n    return {\r\n      active: {\r\n        type: Boolean,\r\n        // Observer method identified by name\r\n        observer: '_activeChanged'\r\n      }\r\n    }\r\n  }\r\n\r\n  // Observer method defined as a class method\r\n  _activeChanged(newValue, oldValue) {\r\n    this.toggleClass('highlight', newValue);\r\n  }\r\n}\r\n`\r\n\r\nComplex observers\r\n\r\n复杂监听器需要在this.observers数组里面注册，复杂监听器可以监听多条路径（依赖）\r\n\r\n`javascript\r\nstatic get observers() {\r\n  return [\r\n    // Observer method name, followed by a list of dependencies, in parenthesis\r\n    'userListChanged(users.*, filter)'\r\n  ]\r\n}\r\n\r\n`\r\n注册函数里面的参数有如下几种：\r\n\r\n一个简单的属性路径 (firstName).\r\n\r\n一个简单的子属性路径 (address.street).\r\n\r\n一个数组的变化结果路径 (users.splices).\r\n\r\n一个包含通配符的路径 (users.*).\r\n\r\n\r\n函数被调用时所得到的参数依据监听的路径种类不同而不同：\r\n\r\n\r\n简单的属性或子属性，传参为新值\r\n数组变化路径，传参为描述变化详情的 变化记录 对象\r\n通配符路径，传参为 变化记录 对象以及变化的详细路径\r\n\r\n\r\nNote that any of the arguments can be undefined when the observer is called.\r\n\r\n监听函数中每次调用，任何一个参数都有可能是undefined\r\n\r\n复杂监听器的参数只有新值没有旧值\r\n\r\n\r\n Observe changes to multiple properties \r\n\r\n`js\r\nclass XCustom extends Polymer.Element {\r\n\r\n  static get is() {return 'x-custom'; }\r\n\r\n  static get properties() {\r\n    return {\r\n        preload: Boolean,\r\n        src: String,\r\n        size: String\r\n    }\r\n  }\r\n\r\n  // Each item of observers array is a method name followed by\r\n  // a comma-separated list of one or more dependencies.\r\n  static get observers() {\r\n    return [\r\n        'updateImage(preload, src, size)'\r\n    ]\r\n  }\r\n\r\n  // Each method referenced in observers must be defined in\r\n  // element prototype. The arguments to the method are new value\r\n  // of each dependency, and may be undefined.\r\n  updateImage(preload, src, size) {\r\n    // ... do work using dependent values\r\n  }\r\n}\r\n`\r\n\r\n\r\nObserve array mutations\r\n\r\n数组变化路径的参数change record是一个对象，包含一个indexSplices数组，数组中的每一项表示一处变更记录，包含下面信息：\r\n\r\nindex. 变更其实的地方\r\nremoved. 被删除的数据\r\naddedCount. 插入的数据长度\r\nobject: 一个指向新数据的数组（不是拷贝）  //A reference to the array in question. 这句话不懂什么意思\r\ntype: 一个值为'splice'的字符串\r\n\r\n\r\n注意： change record也许会为undefined\r\n\r\n\r\n`js\r\nclass XCustom extends Polymer.Element {\r\n\r\n  static get is() {return 'x-custom'; }\r\n\r\n  static get properties() {\r\n    return {\r\n      users: {\r\n        type: Array,\r\n        value: function() {\r\n          return [];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Observe changes to the users array\r\n  static get observers() {\r\n    return [\r\n      'usersAddedOrRemoved(users.splices)'\r\n    ]\r\n  }\r\n\r\n\r\n  // For an array mutation dependency, the corresponding argument is a change record\r\n  usersAddedOrRemoved(changeRecord) {\r\n    if (changeRecord) {\r\n      changeRecord.indexSplices.forEach(function(s) {\r\n        s.removed.forEach(function(user) {\r\n          console.log(user.name + ' was removed');\r\n        });\r\n        for (var i=0; i<s.addedCount; i++) {\r\n          var index = s.index + i;\r\n          var newUser = s.object[index];\r\n          console.log('User ' + newUser.name + ' added at index ' + index);\r\n        }\r\n      }, this);\r\n    }\r\n  }\r\n\r\n  ready() {\r\n    super.ready();\r\n    this.push('users', {name: \"Jack Aubrey\"});\r\n  }\r\n}\r\n\r\ncustomElements.define(XCustom.is, XCustom);\r\n`\r\n\r\n Observe all changes related to a path\r\n通配符路径的参数是一个change record对象，包含：\r\n\r\npath  监听器监听的路径\r\nvalue 新值\r\nbase  通配符之前的路径所代表的对象\r\n\r\n如果通配符路径监听到的是数组的变化，那么\r\n\r\npath则是该数组的路径（不包括.splices）\r\nvalue里面则会包含一个indexSplices项\r\n\r\n`html\r\ndom-module id=\"x-custom\"\r\n  template\r\n    <input value=\"{{user.name.first::input}}\"\r\n           placeholder=\"First Name\"\r\n    <input value=\"{{user.name.last::input}}\"\r\n           placeholder=\"Last Name\"\r\n  /template\r\n  script\r\n    class XCustom extends Polymer.Element {\r\n\r\n      static get is() { return 'x-custom'; }\r\n\r\n      static get properties() {\r\n        return {\r\n          user: {\r\n            type: Object,\r\n            value: function() {\r\n              return {'name':{}};\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      static get observers() {\r\n        return [\r\n            'userNameChanged(user.name.*)'\r\n        ]\r\n      }\r\n\r\n      userNameChanged(changeRecord) {\r\n        console.log('path: ' + changeRecord.path);\r\n        console.log('value: ' + changeRecord.value);\r\n      }\r\n    }\r\n\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n/dom-module\r\n`\r\n\r\n\r\nIdentify all dependencies\r\n\r\nObservers shouldn't rely on any properties, sub-properties, or paths other\r\nthan those listed as dependencies of the observer. This creates \"hidden\" dependencies\r\n\r\n监听器不能依赖任何其他未被注册过的路径，否则：\r\n不能保证该路径是否已经初始化完成\r\n当该路径的属性发生变化时，无法触发当前监听器\r\n\r\n\r\nFor example:\r\n\r\n`js\r\nstatic get properties() {\r\n  return {\r\n    firstName: {\r\n      type: String,\r\n      observer: 'nameChanged'\r\n    },\r\n    lastName: {\r\n      type: String\r\n    }\r\n  }\r\n}\r\n\r\n// WARNING: ANTI-PATTERN! DO NOT USE\r\nnameChanged(newFirstName, oldFirstName) {\r\n  // Not invoked when this.lastName changes\r\n  var fullName = newFirstName + ' ' + this.lastName;\r\n  // ...\r\n}\r\n`\r\n\r\nNote that Polymer doesn't guarantee that properties are\r\ninitialized in any particular order.\r\n\r\nPolymer不能保证属性之间的初始化顺序。\r\n\r\n\r\n Computed properties\r\n\r\nComputed properties are virtual properties computed on the basis of one or more paths. The computing\r\nfunction for a computed property follows the same rules as a complex observer, except that it\r\nreturns a value, which is used as the value of the computed property.\r\n\r\n计算属性定义跟复杂监听器类似，但是计算属性的计算函数需要返回一个值。\r\n\r\n\r\nDefine a computed property\r\n\r\n计算属性需要在properties里面的property配置对象中使用computed键注册，注册语法跟复杂监听器一致。\r\n`javascript\r\ndom-module id=\"x-custom\"\r\n\r\n  template\r\n    My name is span{{fullName}}/span\r\n  /template\r\n\r\n  script\r\n    class XCustom extends Polymer.Element {\r\n\r\n      static get is() { return 'x-custom'; }\r\n\r\n      static get properties() {\r\n        return {\r\n          first: String,\r\n\r\n          last: String,\r\n\r\n          fullName: {\r\n            type: String,\r\n            // when first or last changes computeFullName is called once\r\n            // and the value it returns is stored as fullName\r\n            computed: 'computeFullName(first, last)'\r\n          }\r\n        }\r\n      }\r\n\r\n      computeFullName(first, last) {\r\n        return first + ' ' + last;\r\n      }\r\n    }\r\n\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n\r\n/dom-module\r\n`\r\n\r\n另外见 ： Computed Bindings\r\n\r\n\r\n Dynamic observer methods \r\n\r\nIf the observer method is declared in the properties object, the method is considered dynamic:\r\nthe method itself may change during runtime. A dynamic method is considered an extra dependency of\r\nthe observer, so the observer re-runs if the method itself changes. For example:\r\n\r\n如果一个监听器或者计算属性的方法被定义在了properties里面，那么我们可以动态的对这个方法进行覆盖、重写。\r\n当方法发生变化的时候，新的简单监听器或计算属性会被立即触发或者被更新。\r\n\r\n`js\r\nclass NameCard extends Polymer.Element {\r\n\r\n  static get is() {\r\n    return 'name-card'\r\n  }\r\n\r\n  static get properties() {\r\n    return {\r\n      // Override default format by assigning a new formatter\r\n      // function\r\n      formatter: {\r\n        type: Function\r\n      },\r\n      formattedName: {\r\n        computed: 'formatter(name.title, name.first, name.last)'\r\n      },\r\n      name: {\r\n        type: Object,\r\n        value() {\r\n         return { title: \"\", first: \"\", last: \"\" };\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  constructor() {\r\n    super();\r\n    this.formatter = this.defaultFormatter;\r\n  }\r\n\r\n  defaultFormatter(title, first, last) {\r\n    return ${title} ${first} ${last}\r\n  }\r\n}\r\ncustomElements.define('name-card', NameCard);\r\n`\r\n\r\n`js\r\nnameCard.name = { title: 'Admiral', first: 'Grace', last: 'Hopper'}\r\nconsole.log(nameCard.formattedName); // Admiral Grace Hopper\r\nnameCard.formatter = function(title, first, last) {\r\n  return ${last}, ${first}\r\n}\r\nconsole.log(nameCard.formattedName); // Hopper, Grace\r\n`\r\n计算属性formattedName的方法formatter发生变化的时候,尽管依赖name没有变化，但是该属性还是触发更新了。\r\n\r\n因为动态监听器方法出于properties里面，因此会被看作一个依赖，一旦这个方法被定义，监听器就在初始化的时候触发，尽管其他依赖都没有被定义。\r\n\r\nAdd observers and computed properties dynamically\r\n\r\nIn some cases, you may want to add an observer or computed property dynamically. A set of instance\r\nmethods allow you to add a simple observer, complex observer, or computed property to the current\r\nelement instance.\r\n\r\n使用js API来动态添加计算属性或监听器\r\n_createPropertyObserver\r\n_createMethodObserver \r\n_createComputedProperty\r\n\r\n\r\n Add a simple observer dynamically\r\n`js\r\nthis._observedPropertyChanged = (newVal) = { console.log('observedProperty changed to ' + newVal); };\r\nthis.createPropertyObserver('observedProperty', 'observedPropertyChanged', true);\r\n`\r\n第三个参数代表这个方法(_observedPropertyChanged)是否应该被看作一个依赖\r\n\r\n\r\nAdd a complex observer dynamically\r\n\r\n`js\r\nthis.createMethodObserver('observeSeveralProperties(prop1,prop2,prop3)', true);\r\n`\r\n\r\n第三个参数代表这个方法(_observeSeveralProperties)是否应该被看作一个依赖\r\n\r\n\r\n Add a computed property dynamically\r\n\r\n`js\r\nthis.createComputedProperty('newProperty', 'computeNewProperty(prop1,prop2)', true);\r\n`\r\n第三个参数代表这个方法(_computeNewProperty)是否应该被看作一个依赖",
        "tags": [
            "Polymer"
        ]
    },
    {
        "uri": "/post/polymer-2-6-data-binding",
        "title": "Polymer 2.0 文档笔记(6) Data Binding",
        "content": "\r\nA data binding connects data from a custom element (the host element) to a property or attribute of an element in its local DOM (the child\r\nor target element). The host element data can be a property or sub-property represented by a data path, or data generated based on one or more paths.\r\n\r\n数据绑定能够将host元素和target元素的property或者attribute相互链接床单。这里数据指的是路径(Paths)\r\n\r\nAnatomy of a data binding\r\n\r\n数据绑定有两种绑定方式：\r\n\r\n`html\r\ncustom-element property-name=annotation-or-compound-binding /custom-element\r\ncustom-element attribute-name$=annotation-or-compound-binding/custom-element\r\n`\r\n\r\n=绑定property,$=绑定attribute(href,style,...)\r\nannotation代表数据绑定标记: [[ ]]或者\\{\\{ \\}\\}\r\ncompound-binding:包含标记的字符串: \"my name is {{ name }}\"\r\n\r\n\r\n\r\n Bind to a target property \r\n\r\n将target元素的name属性绑定到当前元素的my-Name属性。\r\n注意驼峰式和dash式命名的转换规则(property name to attribute name mapping)\r\n`html\r\ntarget-element name=\"{{myName}}\"/target-element\r\n`\r\n\r\nBind to text content\r\n\r\n相当于绑定到target元素的textContent属性上\r\n\r\n`js\r\ndom-module id=\"user-view\"\r\n  template\r\n    div[[name]]/div\r\n  /template\r\n\r\n  script\r\n    class UserView extends Polymer.Element {\r\n      static get is() {return 'user-view'}\r\n      static get properties() {\r\n        return {\r\n          name: String\r\n        }\r\n      }\r\n    }\r\n\r\n    customElements.define(UserView.is, UserView);\r\n  /script\r\n/dom-module\r\n\r\n!-- usage --\r\nuser-view name=\"Samuel\"/user-view\r\n`\r\n\r\nBinding to text content is always one-way, host-to-target.\r\n\r\n注意，文字节点的绑定永远都是单向的(host to target)\r\n\r\n Bind to a target attribute\r\nattribute绑定相当于\r\n`javascript\r\nelement.setAttribute(attr,value)\r\n`\r\nproperty绑定相当于\r\n\r\n`javascript\r\nelement.property = 'value'\r\n`\r\n\r\n因此，一些attribute同样可以使用property形式绑定：\r\n`html\r\ntemplate\r\n  !-- Attribute binding --\r\n  my-element selected$=\"[[value]]\"/my-element\r\n  !-- results in <my-element.setAttribute('selected', this.value); --\r\n\r\n  !-- Property binding --\r\n  my-element selected=\"{{value}}\"/my-element\r\n  !-- results in <my-element.selected = this.value; --\r\n/template\r\n`\r\n需要注意的是： attribute形式的数据绑定只能是单向的([[ ]])\r\n\r\nNative properties that don't support property binding\r\n\r\nThere are a handful of common native element properties that Polymer can't data-bind to directly,\r\nbecause the binding causes issues on one or more browsers.\r\n\r\n一些原生的property无法使用=绑定数据，需要使用attribute形式的$=才能成功绑定。\r\n\r\n| Attribute | Property | Notes |\r\n|----|----|----|\r\n| class | classList, className | Maps to two properties with different formats. |\r\n| style | style | By specification, style is considered a read-only reference to a CSSStyleDeclaration object. |\r\n| href | href | |\r\n| for | htmlFor | |\r\n| data-* |  dataset | Custom data attributes (attribute names starting with data-) are stored on the dataset property. |\r\n| value | value | Only for input type=\"number\". |\r\n\r\ndata binding to the value property doesn't work on IE for numeric input types. For\r\nthis specific case, you can use one-way attribute binding to set the value of a numeric input. Or\r\nuse another element such as iron-input or paper-input that handles two-way binding correctly.\r\n\r\n`html\r\n!-- class --\r\ndiv class$=\"[[foo]]\"/div\r\n\r\n!-- style --\r\ndiv style$=\"[[background]]\"/div\r\n\r\n!-- href --\r\na href$=\"[[url]]\"\r\n\r\n!-- label for --\r\nlabel for$=\"[[bar]]\"/label\r\n\r\n!-- dataset --\r\ndiv data-bar$=\"[[baz]]\"/div\r\n\r\n!-- ARIA --\r\nbutton aria-label$=\"[[buttonLabel]]\"/button\r\n\r\n`\r\n Logical not operator \r\n\r\n可以在data-binding表达式前面添加!号取反\r\n\r\n`html\r\ntemplate\r\n  my-page show-login=\"[[!isLoggedIn]]\"/my-page\r\n/template\r\n`\r\n注意：\r\n\r\n逻辑非只能用在单项绑定中使用\r\n只能有一个!不能!!\r\n\r\n\r\n\r\nComputed bindings\r\n\r\ncomputed binding类似于computed property。\r\n`js\r\ndiv[[_formatName(first, last, title)]]/div\r\n`\r\n\r\nAn element can have multiple computed bindings in its template that refer to the same computing\r\nfunction.\r\n一个元素里面可以有多个使用同样的computing function的computed binding\r\n\r\ncomputed binding并不完全等同于computed property，差异有下面几点：\r\n\r\ncomputed binding的依赖路径是相对于元素当前的data scope的\r\ncomputed binding的参数不仅可以有computed property那样的路径参数，也可以是单纯的字符串或者数字等\r\ncomputed binding可以没有参数，这种情况下，函数只会被调用一次\r\ncomputed binding函数要等所有的参数中的依赖全部初始化(!=undefined)之后才会执行\r\n\r\n`html\r\ndom-module id=\"x-custom\"\r\n\r\n  template\r\n    My name is span[[_formatName(first, last)]]/span\r\n  /template\r\n\r\n  script\r\n    class XCustom extends Polymer.Element {\r\n      static get is() {return 'x-custom'}\r\n      static get properties() {\r\n        return {\r\n          first: String,\r\n          last: String\r\n        }\r\n      }\r\n      _formatName(first, last) {\r\n        return ${last}, ${first}\r\n      }\r\n\r\n    }\r\n\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n\r\n/dom-module\r\n`\r\n\r\nCommas in literal strings: Any comma occurring in a string literal must be escaped using a\r\nbackslash (\\).\r\n\r\n如果参数是字符串，那么字符串里面所有的逗号都要被转义\r\n\r\n`html\r\ndom-module id=\"x-custom\"\r\n  template\r\n    span{{translate('Hello\\, nice to meet you', first, last)}}/span\r\n  /template\r\n/dom-module\r\n`\r\n\r\nComputed bindings are one-way. A computed binding is always one-way, host-to-target.\r\n\r\ncomputed binding只能在单向绑定中使用\r\n\r\n\r\n Compound bindings\r\n\r\n可以在字符串里面或者textContent里面使用绑定标记\r\n`html\r\nimg src$=\"https://www.example.com/profiles/[[userId]].jpg\"\r\n\r\nspanName: [[lastname]], [[firstname]]/span\r\n`\r\n注意：\r\n\r\nundefined会输出成空字符串\r\nCompound binding永远是单向绑定，虽然你也可以使用\\{\\{ \\}\\}记号。\r\n\r\n\r\n\r\n\r\nBinding to array items\r\n\r\nTo keep annotation parsing simple, **Polymer doesn't provide a way to bind directly to an array\r\nitem**.\r\n\r\n为了解析简单，Polymer无法直接绑定一个数组里面的元素\r\n\r\n`html\r\n!-- Don't do this! --\r\nspan{{array[0]}}/span\r\n!-- Or this! --\r\nspan{{array.0}}/span\r\n`\r\n\r\n有下面几种方法可以解决： \r\ndom-repeat里面已经为每个数组里面的元素创建了一个子scope，因此可以直接binding\r\narray-selector 同上，可以直接绑定一个元素或者被选择的元素集合\r\n使用computed binding来间接绑定，见下面例子\r\n`html\r\ndom-module id=\"x-custom\"\r\n\r\n  template\r\n    div[[arrayItem(myArray.*, 0, 'name')]]/div\r\n    div[[arrayItem(myArray.*, 1, 'name')]]/div\r\n  /template\r\n\r\n  script\r\n\r\n    class XCustom extends Polymer.Element {\r\n\r\n      static get is() {return 'x-custom'}\r\n\r\n      static get properties() {\r\n        return {\r\n          myArray: {\r\n            type: Array,\r\n            value: [{ name: 'Bob' }, { name: 'Doug' }]\r\n          }\r\n        }\r\n      }\r\n\r\n      // first argument is the change record for the array change,\r\n      // change.base is the array specified in the binding\r\n      arrayItem(change, index, path) {\r\n        // this.get(path, root) returns a value for a path\r\n        // relative to a root object.\r\n        return this.get(path, change.base[index]);\r\n      },\r\n\r\n      ready() {\r\n        super.ready();\r\n        // mutate the array\r\n        this.unshift('myArray', { name: 'Susan' });\r\n        // change a subproperty\r\n        this.set('myArray.1.name', 'Rupert');\r\n      }\r\n    }\r\n\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n\r\n/dom-module\r\n`\r\n\r\n Two-way binding to a non-Polymer element\r\n\r\n为了达到非Polymer元素上面的双向绑定，可以使用下面的标记：\r\n`js\r\ntarget-prop=\"{{hostProp::target-change-event}}\"\r\n`\r\n`html\r\n!-- Listens for input event and sets hostValue to <input.value --\r\ninput value=\"{{hostValue::input}}\"\r\n\r\n!-- Listens for change event and sets hostChecked to <input.checked --\r\ninput type=\"checkbox\" checked=\"{{hostChecked::change}}\"\r\n\r\n!-- Listens for timeupdate  event and sets hostTime to <video.currentTime --\r\nvideo url=\"...\" current-time=\"{{hostTime::timeupdate}}\"\r\n`\r\n基于约定大于配置的原理，如果target-prop的变化通知函数是target-prop-changed则该定义可以省略。\r\n\r\n`html\r\n!-- Listens for value-changed event --\r\nmy-element value=\"{{hostValue::value-changed}}\"\r\n\r\n!-- Listens for value-changed event using Polymer convention by default --\r\nmy-element value=\"{{hostValue}}\"\r\n`\r\n",
        "tags": [
            "Polymer"
        ]
    },
    {
        "uri": "/post/polymer-2-7-helper-element",
        "title": "Polymer 2.0 文档笔记(7) Helper Element",
        "content": "\r\n\r\nPolymer提供一系列的自定义元素来简化一些共有的数据绑定逻辑：\r\n\r\ndom-repeat 遍历显示数组\r\narray-selector 数组选择器\r\ndom-if 条件显示\r\ndom-bind 自动绑定\r\n\r\n\r\n2.0 tip. The data binding helper elements are bundled in to the backward-compatible,\r\npolymer.html import. If you aren't using the legacy import, you'll need to import the\r\nhelper elements you're using.\r\n\r\n为了向前兼容，polymer.html引入了所有的helper元素，而2.0的polymer.Element则要按照需要一个个手动引入。\r\n\r\n\r\n\r\nTemplate repeater (dom-repeat)\r\n\r\ndom-repeat需要绑定一个数组，遍历显示里面元素，并为每个数组元素创建一个新的data scope，包括下面两个属性：\r\n\r\nitem 数组元素\r\nindex 元素下标\r\n\r\n有两种用法:\r\n\r\n在Polymer element template内部，可以直接使用简写\r\n    `html\r\n      template is=\"dom-repeat\" items=\"{{items}}\"\r\n        ...\r\n      /template\r\n    `\r\n在Polymer element template外部，使用dom-repeat标签\r\n    `html\r\n        dom-repeat\r\n          template\r\n            ...\r\n          /template\r\n        /dom-repeat\r\n    `\r\n    在这种情况下，还需要手动使用js给dom-repeat标签设置数据：\r\n    `js\r\n        var repeater = document.querySelector('dom-repeat');\r\n        repeater.items = someArray;\r\n    `\r\n\r\n`html\r\nlink rel=\"import\" href=\"components/polymer/polymer-element.html\"\r\n! -- import template repeater --\r\nlink rel=\"import\" href=\"components/polymer/lib/elements/dom-repeat.html\"\r\n\r\ndom-module id=\"x-custom\"\r\n  template\r\n    div Employee list: /div\r\n    template is=\"dom-repeat\" items=\"{{employees}}\"\r\n        div [[index]]/div\r\n        divFirst name: span[[item.first]]/span/div\r\n        divLast name: span[[item.last]]/span/div\r\n    /template\r\n  /template\r\n\r\n  script\r\n    class XCustom extends Polymer.Element {\r\n\r\n      static get is() { return 'x-custom'; }\r\n\r\n      static get properties() {\r\n        return {\r\n          employees: {\r\n            type: Array,\r\n            value() {\r\n              return [\r\n                {first: 'Bob', last: 'Smith'},\r\n                {first: 'Sally', last: 'Johnson'},\r\n              ];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n\r\n/dom-module\r\n`\r\n需要使用可被监听的手段去更改dom-repeat绑定的数组\r\n\r\n`js\r\n// Use Polymer array mutation methods:\r\nthis.push('employees', {first: 'Diana', last: 'Villiers'});\r\n\r\n// Use Polymer set method:\r\nthis.set('employees.2.last', 'Maturin');\r\n\r\n// Use native methods followed by notifyPath\r\nthis.employees.push({first: 'Barret', last: 'Bonden'});\r\nthis.notifyPath('employees');\r\n`\r\n\r\n\r\nHandling events in dom-repeat templates {handling-events}\r\n\r\nWhen handling events generated by a dom-repeat template instance, you\r\nfrequently want to map the element firing the event to the model data that\r\ngenerated that item.\r\n\r\nWhen you add a declarative event handler inside the dom-repeat template,\r\nthe repeater adds a model property to each event sent to the listener. The model\r\nobject contains the scope data used to generate the template instance, so the item\r\ndata is model.item:\r\n\r\n当你帮定义一个事件到dom-repeat的内部元素之后，事件参数e会有一个model项，代表着当前元素的data scope.\r\n\r\n\r\n`html\r\nlink rel=\"import\" href=\"polymer/polymer-element.html\"\r\nlink rel=\"import\" href=\"polymer/lib/elements/dom-repeat.html\"\r\n\r\ndom-module id=\"x-custom\"\r\n\r\n  template\r\n    template is=\"dom-repeat\" id=\"menu\" items=\"{{menuItems}}\"\r\n        div\r\n          span{{item.name}}/span\r\n          span{{item.ordered}}/span\r\n          button on-click=\"order\"Order/button\r\n        /div\r\n    /template\r\n  /template\r\n\r\n  script\r\n    class XCustom extends Polymer.Element {\r\n\r\n      static get is() { return 'x-custom'; }\r\n\r\n      static get properties() {\r\n        return {\r\n          menuItems: {\r\n            type: Array,\r\n            value() {\r\n              return [\r\n                {name: 'Pizza', ordered: 0},\r\n                {name: 'Pasta', ordered: 0},\r\n                {name: 'Toast', ordered: 0}\r\n              ];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      order(e) {\r\n        e.model.set('item.ordered', e.model.item.ordered+1);\r\n      }\r\n    }\r\n\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n\r\n/dom-module\r\n`\r\n\r\nThe model is an instance of TemplateInstance, which provides the Polymer\r\ndata APIs: get, set, setProperties, notifyPath and the array manipulation methods.\r\nYou can use these to manipulate the model, using paths relative to template instance.\r\n\r\nmodel也是一个TemplateInstance的子类，提供了get,set,setProperties,notifyPath等data API\r\n\r\n只有在dom-repeat里面绑定过的属性才会赋给model，如下面例子，将productId绑定到不可见的自定义属性上，以便将productId添加到model对象中。\r\n\r\n\r\n`html\r\n  template is=\"dom-repeat\" items=\"{{products}}\" as=\"product\"\r\n    div product-id=\"[[product.productId]]\"[[product.name]]/div\r\n  /template\r\n`\r\n\r\nHandling events outside the dom-repeat template.\r\n\r\nThe model property is not added for event listeners registered imperatively (using addEventListener), or listeners added to one of the dom-repeat template's parent nodes. In these cases, you can use the dom-repeat modelForElement method to retrieve the model data that generated a given element. (There are also corresponding itemForElement and indexForElement methods.)\r\n外部如果使用标准的DOM APIaddEventListener来监听子元素的事件时，则事件参数里面没有e.model属性，可以使用下面几个函数手动获得：\r\n\r\ndom-repeat.modelForElement\r\ndom-repeat.itemForElement\r\ndom-repeat.indexForElement\r\n\r\n\r\n Filtering and sorting lists\r\n\r\nTo filter or sort the displayed items in your list, specify a filter or\r\nsort property on the dom-repeat (or both):\r\n可以在dom-repeat上指定filter或sort的方法。\r\n\r\n\r\n默认，filter和sort方法只在两种情况下被调用：\r\n数组发生可被监控的变化(observable change)\r\n两者方法被动态重现、改变\r\n\r\n使用render方法强制filter和sort方法重新执行。（见Forcing synchronous renders）\r\n\r\n\r\nTo re-run the filter or sort functions when certain sub-fields of items change, set the observe property to a space-separated list of item sub-fields that should cause the list to be re-filtered or re-sorted.\r\n\r\n如果filter/sort是依据数组元素的某一个子属性来排序的，需要在dom-repeat标签上设置一个observe属性，将过滤或排序依据的子属性按照空格连接起来的字符设为它的值。\r\n比如，下面这个例子，设置一个叫isEngineer的filter：\r\n\r\n`js\r\nisEngineer: function(item) {\r\n    return item.type == 'engineer' || item.manager.type == 'engineer';\r\n}\r\n`\r\n\r\n在dom-repeat标签上设置过滤器所使用过的元素子属性type manager.type\r\n\r\n`html\r\n<template is=\"dom-repeat\" items=\"{{employees}}\"\r\n    filter=\"isEngineer\" observe=\"type manager.type\"\r\n`\r\n\r\n\r\n修改第0个元素中的manager.type将会导致整个列表重新过滤\r\n`js\r\nthis.set('employees.0.manager.type', 'engineer');\r\n`\r\n\r\n\r\nDynamic sort and filter changes\r\nobserve属性并不能完全解决所有需求，也许filter/sort函数需要用到其他地方的变量，因此我们可以实现一个computed binding来动态返回一个filter/sort函数\r\n\r\n`html\r\ndom-module id=\"x-custom\"\r\n\r\n  template\r\n    input value=\"{{searchString::input}}\"\r\n\r\n    !-- computeFilter returns a new filter function whenever searchString changes --\r\n    <template is=\"dom-repeat\" items=\"{{employees}}\" as=\"employee\"\r\n        filter=\"{{computeFilter(searchString)}}\"\r\n        div{{employee.lastname}}, {{employee.firstname}}/div\r\n    /template\r\n  /template\r\n\r\n  script\r\n    class XCustom extends Polymer.Element {\r\n\r\n      static get is() { return 'x-custom'; }\r\n\r\n      static get properties() {\r\n        return {\r\n          employees: {\r\n            type: Array,\r\n            value() {\r\n              return [\r\n                { firstname: \"Jack\", lastname: \"Aubrey\" },\r\n                { firstname: \"Anne\", lastname: \"Elliot\" },\r\n                { firstname: \"Stephen\", lastname: \"Maturin\" },\r\n                { firstname: \"Emma\", lastname: \"Woodhouse\" }\r\n              ]\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      computeFilter(string) {\r\n        if (!string) {\r\n          // set filter to null to disable filtering\r\n          return null;\r\n        } else {\r\n          // return a filter function for the current search string\r\n          string = string.toLowerCase();\r\n          return function(employee) {\r\n            var first = employee.firstname.toLowerCase();\r\n            var last = employee.lastname.toLowerCase();\r\n            return (first.indexOf(string) != -1 ||\r\n                last.indexOf(string) != -1);\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n/dom-module\r\n`\r\n\r\n\r\n Filtering on array index \r\n\r\nBecause of the way Polymer tracks arrays internally, the array index isn't passed to the filter function. Looking up the array index for an item is an O(n) operation. Doing so  in a filter function could have significant performance impact.\r\n\r\n不能获得数组索引，只能通过this.items获得原来数组，再通过indexOf方法获得索引，效率低下。\r\n注意，filter/sort方法中，不是数组元素所创建的子data scope\r\n\r\n\r\n`js\r\nfilter: function(item) {\r\n  var index = this.items.indexOf(item);\r\n  ...\r\n}\r\n`\r\n\r\nNesting dom-repeat templates {nesting-templates}\r\n\r\nWhen nesting multiple dom-repeat templates, you may want to access data\r\nfrom a parent scope. Inside a dom-repeat, you can access any properties available\r\nto the parent scope unless they're hidden by a property in the current scope.\r\n比如类继承一样，子scope中可以取父scope的所有没有被覆盖的属性。\r\n\r\nTo access properties from nested dom-repeat templates, use the as attribute to\r\nassign a different name for the item property. Use the index-as attribute to assign a\r\ndifferent name for the index property.\r\n可以使用as标记来对默认的item来重命名\r\n可以使用index-as标记来对默认的index来重命名\r\n\r\n`html\r\ndiv Employee list: /div\r\ntemplate is=\"dom-repeat\" items=\"{{employees}}\" as=\"employee\"\r\n    divFirst name: span{{employee.first}}/span/div\r\n    divLast name: span{{employee.last}}/span/div\r\n\r\n    divDirect reports:/div\r\n\r\n    template is=\"dom-repeat\" items=\"{{employee.reports}}\" as=\"report\" index-as=\"report_no\"\r\n      divspan{{report_no}}/span.\r\n           span{{report.first}}/span span{{report.last}}/span\r\n      /div\r\n    /template\r\n/template\r\n`\r\n\r\nForcing synchronous renders \r\n\r\n默认的dom-repeat是异步执行的，但是可以调用render方法使之立即同步渲染。\r\n此方法性能代价比较大，适用于下面几种情况：\r\n\r\n单元测试的时候保证检查之前所有的选项都被渲染完毕\r\n在要滚动到某一特定元素之前保证其已经渲染完毕\r\n当外部数据变化导致的sort/filter方法需要重新运行\r\n\r\n注意： render方法只会更新模型数据的Observable change，如果要全局更新见下一节。\r\n\r\n Forcing the template to update\r\n强制刷新列表元素，像之前所说过的三种解决方案：\r\n\r\nnotifySplices，如果你知道数组的具体变更方式\r\n克隆数组，如果必要，可以深度克隆，性能不佳\r\n使用mutableData标签再this.notifyPath(items)\r\n\r\n\r\nImprove performance for large lists\r\n\r\n当列表数据量很大的时候，dom-repeat支持延迟加载。设置initialCount属性，可以启动chunked mode，dom-repeat首先会渲染initialCount个元素，然后按照一个animation frame一chunk的形式渲染其他元素，这样能够让UI在渲染的过程中处理用户的输入。可以查看renderedItemCount属性（只读）来获得当前已被渲染的元素总数。\r\n\r\ndom-repeat adjusts the number of items rendered in each chunk to try and maintain a target framerate. You can further tune rendering by setting targetFramerate.\r\n\r\ndom-repeat尝试去维护一个targetFramerate函数来调整每一个渲染的chunk里面的元素个数，具体：targetFramerate\r\n\r\n\r\n\r\n\r\n Data bind an array selection (array-selector) \r\n\r\nKeeping structured data in sync requires that Polymer understand the path associations of data being bound.  The array-selector element ensures path linkage when selecting specific items from an array.\r\n\r\narray-selector 可以选择数组里面的元素，并自动把选择出来的元素的路径跟这些元素的原来路径进行连接。(linkPaths)\r\n\r\n`html\r\nlink rel=\"import\" href=\"components/polymer/polymer-element.html\"\r\n! -- import template repeater --\r\nlink rel=\"import\" href=\"components/polymer/lib/elements/dom-repeat.html\"\r\n!-- import array selector --\r\nlink rel=\"import\" href=\"components/polymer/lib/elements/array-selector.html\"\r\n\r\ndom-module id=\"x-custom\"\r\n\r\n  template\r\n\r\n    div Employee list: /div\r\n    template is=\"dom-repeat\" id=\"employeeList\" items=\"{{employees}}\"\r\n        divFirst name: span{{item.first}}/span/div\r\n        divLast name: span{{item.last}}/span/div\r\n        button on-click=\"toggleSelection\"Select/button\r\n    /template\r\n\r\n    array-selector id=\"selector\" items=\"{{employees}}\" selected=\"{{selected}}\" multi toggle/array-selector\r\n\r\n    div Selected employees: /div\r\n    template is=\"dom-repeat\" items=\"{{selected}}\"\r\n        divFirst name: span{{item.first}}/span/div\r\n        divLast name: span{{item.last}}/span/div\r\n    /template\r\n\r\n  /template\r\n\r\n  script\r\n    class XCustom extends Polymer.Element {\r\n\r\n      static get is() { return 'x-custom'; }\r\n\r\n      static get properties() {\r\n        return {\r\n          employees: {\r\n            type: Array,\r\n            value() {\r\n              return [\r\n                {first: 'Bob', last: 'Smith'},\r\n                {first: 'Sally', last: 'Johnson'},\r\n                // ...\r\n              ];\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      toggleSelection(e) {\r\n        var item = this.$.employeeList.itemForElement(e.target);\r\n        this.$.selector.select(item);\r\n      }\r\n    }\r\n\r\n    customElements.define(XCustom.is, XCustom);\r\n  /script\r\n\r\n/dom-module\r\n`\r\n\r\nitems属性接收一个数组。\r\n两个常见API: select(item)\\deselect(item)\r\n对于数组元素子属性的任何变化都会同步到items数组中（path已经link了）\r\nmulti属性可以开关多选\r\n\r\n\r\nConditional templates (dom-if)\r\n\r\ndom-if 可以按条件来显示其中的内容。最开始的时候dom-if中没有元素，当把if属性设置为true时里面就会出现template中的的元素，当if属性再次变为false时，其内部元素默认不会被删除，而是直接隐藏。可以设置restamp为true来禁止这种隐藏行为。\r\n\r\n跟dom-if一样，有两种方式来定义：\r\n\r\n在Polymer element template内部，使用简写方式\r\n\r\n   `html\r\n    template is=\"dom-if\" if=\"{{condition}}\"\r\n      ...\r\n    /template\r\n    `\r\n在Polymer element template外部，使用dom-if标签\r\n    `html\r\n    dom-if\r\n      template\r\n        ...\r\n      /template\r\n    /dom-if \r\n    `\r\n    这种情况需要手动设置dom-if的属性：\r\n    `js\r\n    var conditional = document.querySelector('dom-if');\r\n    conditional.if = true;\r\n    `\r\n\r\n代码实例：\r\n\r\n  `html\r\n  link rel=\"import\" href=\"components/polymer/polymer-element.html\"\r\n  ! -- import conditional template --\r\n  link rel=\"import\" href=\"components/polymer/lib/elements/dom-if.html\"\r\n\r\n  dom-module id=\"x-custom\"\r\n\r\n    template\r\n\r\n      !-- All users will see this --\r\n      my-user-profile user=\"{{user}}\"/my-user-profile\r\n\r\n\r\n      template is=\"dom-if\" if=\"{{user.isAdmin}}\"\r\n        !-- Only admins will see this. --\r\n        my-admin-panel user=\"{{user}}\"/my-admin-panel\r\n      /template\r\n\r\n    /template\r\n\r\n    script\r\n      class XCustom extends Polymer.Element {\r\n\r\n        static get is() { return 'x-custom'; }\r\n\r\n        static get properties() {\r\n          return {\r\n            user: Object\r\n          }\r\n        }\r\n\r\n      }\r\n\r\n      customElements.define(XCustom.is, XCustom);\r\n    /script\r\n\r\n  /dom-module\r\n  `\r\nConditional templates introduce some overhead, so they shouldn't be used for small UI elements that could be easily shown and hidden using CSS.\r\n\r\n条件模板会引入一些开销，因此不适合一些可以直接设置CSS来控制显示和隐藏的小元素。\r\n但是条件模板也适用于下面几种情况：\r\n\r\n懒惰加载\r\n节省大型复杂网站的内存消耗（restam=true会带来性能上的损失）\r\n\r\n\r\n Auto-binding templates (dom-bind）\r\nPolymer data binding is only available in templates that are managed by Polymer. So data binding works inside an element's DOM template (or inside a dom-repeat or dom-if template), but not for elements placed in the main document.\r\n\r\nTo use Polymer bindings without defining a new custom element, use the dom-bind element.  This template immediately stamps the contents of its child templateinto the main document. Data bindings in an auto-binding template use the dom-bind element itself as the binding scope.\r\n\r\nPolymer的数据绑定只能在template中，为了简化流程，使用自动绑定(dom-bind)能够在不定义新的自定义元素的前提下进行数据绑定。\r\n\r\n`html\r\n!doctype html\r\nhtml\r\nhead\r\n  meta charset=\"utf-8\"\r\n  script src=\"components/webcomponentsjs/webcomponents-lite.js\"/script\r\n  link rel=\"import\" href=\"polymer/lib/elements/dom-bind.html\"\r\n  link rel=\"import\" href=\"polymer/lib/elements/dom-repeat.html\"\r\n\r\n/head\r\nbody\r\n  !-- Wrap elements with auto-binding template to --\r\n  !-- allow use of Polymer bindings in main document --\r\n  dom-bind\r\n    template\r\n\r\n      template is=\"dom-repeat\" items=\"{{data}}\"\r\n        div{{item.name}}: {{item.price}}/div\r\n      /template\r\n\r\n    /template\r\n  /dom-bind\r\n  script\r\n    var autobind = document.querySelector('dom-bind');\r\n\r\n    // The dom-change event signifies when the template has stamped its DOM.\r\n    autobind.addEventListener('dom-change', function() {\r\n      console.log('template is ready.')\r\n    });\r\n\r\n    // set data property on dom-bind\r\n    autobind.data = [\r\n      { name: 'book', price: '$5.00'},\r\n      { name: 'pencil', price: '$1.00'},\r\n      { name: 'flux capacitor', price: '$8,000,000.00'}\r\n    ];\r\n  /script\r\n/body\r\n/html\r\n`\r\n\r\n注意：\r\n\r\n自动绑定只能在Polymer element之外定义(因此只有一种定义方式)\r\ndom-bind也提供了一个render方法来进行强制同步刷新。\r\ndom-bind同样也用一个mutableData属性来开关脏检测机制。\r\n\r\n\r\n\r\ndom-change event\r\n\r\nWhen one of the template helper elements updates the DOM tree, it fires a dom-change event.\r\n\r\n当任意一个template helper elements更新了DOM树时，它们都会触发一个dom-change事件。\r\n\r\nIn most cases, you should interact with the created DOM by changing the model data, not by interacting directly with the created nodes. For those cases where you need to access the nodes directly, you can use the dom-change event.\r\n\r\n原则上，我们不应该直接与DOM进行交互，而应该修改对应的模型数据。如果的确需要这样做的话，可以监听这个的dom-change事件来完成。\r\n",
        "tags": [
            "Polymer"
        ]
    },
    {
        "uri": "/post/shadowsocks-account",
        "title": "Shadowsocks免费账号网址集",
        "content": "\r\nG+圈子很多这样的网站，大部分是由ss-panel这个开源项目建成。不知道他们是乐于分享还是另有目的。下面是列表：\r\n\r\nShadow X(ss-panel作者)\r\nkuaishangSS\r\npepsishadowsocks\r\nChangZ\r\nssserver\r\n\r\n另外推荐Linux下ss GUI客户端：shadowsocks-qt5",
        "tags": []
    },
    {
        "uri": "/post/sublime-config-web",
        "title": "用Sublime Text 3 dev 做网页开发的配置",
        "content": "\r\n\r\n文件：click here",
        "tags": []
    },
    {
        "uri": "/post/timus-1996-cipher-message-3-kmpfft",
        "title": "Timus 1996 Cipher Message 3 KMP+FFT求卷积",
        "content": "\r\n\r\n题目链接：click here\r\ndescription\r\nEmperor Palpatine has been ruling the Empire for 25 years and Darth Vader has been the head of the Empire Armed Forces. However, the Rebel movement is strong like it never used to be. One of the rebel leaders, Princess Leia from Alderaan, managed to get hold of secret blueprints of the Death Star, the imperial war station.\r\n\r\nThe Princess was going to deliver the station plan to the secret base for further analysis and searching for vulnerable spots. But her ship was attacked by the space destroyer \"Devastator\" headed by Darth Vader. At the last moment Princess Leia managed to send her findings to one of the closest planet called Tatooine with her droid R2-D2\\. Quite conveniently, an old friend of her father Obi-Wan Kenobi lives on that planet.\r\n\r\nR2-D2 realizes the importance of his mission. He is going to encrypt the information so that the wrong people won’t get it.\r\n!--more--\r\nThe memory of R2-D2 has many files with images. First he wanted to use a well-known encrypting algorithm. The point of the method is to replace the least significant bits of the image with the encrypted message bits. The difference is practically unnoticeable on the picture, so one won’t suspect that it contains a hidden message.\r\n\r\nBut then R2-D2 decided that this method is quite well-known and the information won’t be protected enough. He decided to change the least significant bits of the image so that the secret information was a continuous sequence of the bytes of the image file. Help the droid determine if it is possible. And if it is, find the minimum number of bits to alter.\r\n\r\n Input\r\n\r\nThe first line of the input contains integers n_ and _m (1 ≤ n_, _m ≤ 250 000) — the sizes of the image file and of the file with the secret information in bytes. On the second line the content of the file with an image is given and the third line contains the secret information. The files are given as a sequence of space-separated bytes. Each byte is written as a sequence of eight bits in the order from the most to the least significant bit.\r\n\r\nOutput\r\n\r\nPrint \"No\", if it is impossible to encrypt information in this image. Otherwise, print in the first line \"Yes\", and in the second line — the number of bits to alter and the number of the byte in the file with the image, starting from which the secret information will be recorded. If there are multiple possible variants, print the one where the secret information is written closer to the beginning of the image file.\r\n\r\n Samples\r\n| input | output |\r\n|",
        "tags": []
    },
    {
        "uri": "/post/wine-font-config",
        "title": "优化Wine程序的字体显示",
        "content": "\r\n\r\n默认Wine的字体太难看，而且有时候还会显示不出来。开启Wine字体的反锯齿及平滑功能以及将字体映射成文泉驿微米黑的方法是：\r\n\r\n1.新建文本文件a.reg，放入如下内容：\r\n!--more--\r\n`language\r\nREGEDIT4\r\n\r\n[HKEYCURRENTUSER\\Software\\Wine\\X11 Driver]\r\n\"ClientSideAntiAliasWithCore\"=\"Y\"\r\n\"ClientSideAntiAliasWithRender\"=\"Y\"\r\n\"ClientSideWithRender\"=\"Y\"\r\n\r\n[HKEYCURRENTUSER\\Control Panel\\Desktop]\r\n\"FontSmoothing\"=\"2\"\r\n\"FontSmoothingType\"=dword:00000002\r\n\"FontSmoothingGamma\"=dword:00000578\r\n\"FontSmoothingOrientation\"=dword:00000001\r\n\r\n[HKEYLOCALMACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes]\r\n\"Arial Baltic,186\"=\"WenQuanYi Micro Hei\"\r\n\"Arial CE,238\"=\"WenQuanYi Micro Hei\"\r\n\"Arial CYR,204\"=\"WenQuanYi Micro Hei\"\r\n\"Arial Greek,161\"=\"WenQuanYi Micro Hei\"\r\n\"Arial TUR,162\"=\"WenQuanYi Micro Hei\"\r\n\"Courier New Baltic,186\"=\"WenQuanYi Micro Hei\"\r\n\"Courier New CE,238\"=\"WenQuanYi Micro Hei\"\r\n\"Courier New CYR,204\"=\"WenQuanYi Micro Hei\"\r\n\"Courier New Greek,161\"=\"WenQuanYi Micro Hei\"\r\n\"Courier New TUR,162\"=\"WenQuanYi Micro Hei\"\r\n\"Helv\"=\"WenQuanYi Micro Hei\"\r\n\"Helvetica\"=\"WenQuanYi Micro Hei\"\r\n\"MS Shell Dlg\"=\"WenQuanYi Micro Hei\"\r\n\"MS Shell Dlg 2\"=\"WenQuanYi Micro Hei\"\r\n\"Tahoma\"=\"WenQuanYi Micro Hei\"\r\n\"Times\"=\"WenQuanYi Micro Hei\"\r\n\"Times New Roman Baltic,186\"=\"WenQuanYi Micro Hei\"\r\n\"Times New Roman CE,238\"=\"WenQuanYi Micro Hei\"\r\n\"Times New Roman CYR,204\"=\"WenQuanYi Micro Hei\"\r\n\"Times New Roman Greek,161\"=\"WenQuanYi Micro Hei\"\r\n\"Times New Roman TUR,162\"=\"WenQuanYi Micro Hei\"\r\n\"Tms Rmn\"=\"WenQuanYi Micro Hei\"\r\n\"Simsun\"=\"WenQuanYi Micro Hei\"\r\n`\r\n\r\n2.如果是普通的wine直接终端输入wine regedit打开注册表编辑器。然后点击“注册表—&gt;导入注册表文件\"导入该文件。\r\n\r\n3.如果是longene等封装好的wine（比如tm2013）可以使用tm2013 -reg命令打开注册表。\r\n\r\n",
        "tags": []
    },
    {
        "uri": "/post/zjnu2073-geasscode",
        "title": "内网2073 城主GeassCode",
        "content": "\r\nDescription\r\n\r\nGeassCode凭借自己在topcoder上的超凡表现，赢得了国王的喜爱，国王赏赐他一座城池。这座城池里有n个 村子，m条路连接这些村子。坐上城主的GeassCode决定要修路，他打算用最少的代价把所以的村子连在一起。据探子回报，有些村子之间虽然原来没有路 径，但是可以强行的去建一条路。GeassCode想知道，如果强行在某两个村子之间建一条路，最后的总花费是多少？\r\n\r\n!--more--\r\n\r\nInput\r\n\r\n输入一行三个整数n，m，表示有n个村子，m条可建路径。\r\n\r\n2..m+1行，每行3个整数a,b,c（a≠b），表示可以在a和b村庄建一条花费为c的路径。\r\n\r\n第m+2行一个整数q，表示有多少个询问。\r\n\r\n接下来q个询问，每行3个整数a,b,c（a≠b），表示如果可以另外在a和b村庄建一条花费为c的路径，最终需要多少花费？\r\n\r\nOutput\r\n\r\n对于每个询问输出，输出最少的花费。\r\n\r\n\r\nSample Input\r\n4 5 1 2 4 2 3 3 1 4 6 2 4 3 1 3 2 3 3 4 3 1 3 1 1 4 2\r\n\r\nSample Output\r\n8 7 7\r\n\r\nHint\r\nn的范围[2,50000],m的范围[2,100000],q的范围[1,50000]。\r\n\r\n输入的m条边保证可以把所有村庄连在一起。输入的边权范围[1,10sup6/sup]\r\n\r\nSource\r\n\r\n张超\r\nbr/\r\n\r\n- -\r\n\r\n\r\n解法是如果可以在(u,v)上再加条边，则将最小生成树上的(u,v)节点最短路径中的最大边权与要加上这条边的替换。如果新的花费比旧的花费少，则取新的花费。否则什么也不换，取旧的花费。\r\n\r\n如何求树上两点之间的最短路径中的最大边权呢？\r\n\r\n可以按照这篇文章所述建一个类似于哈夫曼树，将点作为叶子，边的权值作为祖先构造一个N+N的树：click here\r\n\r\n这样写的很容易错，尤其要区分两颗树的规模，我在这上面错了很久。\r\n\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clrA(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\ndefine N 50005\r\ndefine M 100005\r\nint n, m ;\r\nstruct Graph {\r\n    int u, v, w;\r\n    bool mark;\r\n    bool operator&lt;(Graph othr) const {\r\n        return w &lt; othr.w;\r\n    }\r\n} g[M];\r\n//UnionSet\r\nint p[N + N];\r\nvoid initUset(int n) {\r\n    for (int i = 0; i &lt;= n; i++)\r\n        p[i] = i;\r\n}\r\nint uFind(int x) {\r\n    return x == p[x] ? p[x] : p[x] = uFind(p[x]);\r\n}\r\nvoid uMerge(int x, int y) { //y合并到x\r\n    int fx = uFind(x);\r\n    int fy = uFind(y);\r\n    if (fx != fy) p[fy] = fx;\r\n}\r\n//Edge Graph\r\nint head[N + N], pos;\r\nstruct Edge {\r\n    int v, nxt;\r\n} e[N + N];\r\nvoid initEdge() {\r\n    memset(head, -1, sizeof(head));\r\n    pos = 0;\r\n}\r\nvoid add(int u, int v) {\r\n    e[pos].v = v;\r\n    e[pos].nxt = head[u];\r\n    head[u] = pos++;\r\n}\r\nint size;\r\nvector&lt;pr&lt;int, int&gt; &gt; query[N];\r\nint qw[N];\r\nbool vis[N];\r\nint lca[N];\r\nint val[N + N];\r\nint dfs(int u) {\r\n    int solved = 0;\r\n    for (int i = head[u]; ~i; i = e[i].nxt) {\r\n        int v = e[i].v;\r\n        solved += dfs(v);\r\n        if (size == solved) return solved;\r\n        uMerge(u, v);\r\n    }\r\n    if(~val[u])return solved;\r\n    vis[u] = 1;\r\n    for (int i = 0; i &lt; (int) query[u].size(); i++) {\r\n        int v = queryu.F;\r\n        if (vis[v]) {\r\n            solved++;\r\n            lcaquery[u.S] = uFind(v);\r\n        }\r\n    }\r\n    return solved;\r\n}\r\nvoid tarjan() {\r\n    initUset(n);\r\n    clrA(vis, 0);\r\n    dfs(n);\r\n}\r\nvoid rebuild() {\r\n    clrA(val, -1);\r\n    initUset(n + n);\r\n    initEdge();\r\n    for (int i = 1; i &lt;= m; i++) {\r\n        if (g[i].mark == false) continue;\r\n        val[++n] = g[i].w;\r\n        int fu = uFind(g[i].u);\r\n        int fv = uFind(g[i].v);\r\n        p[fu] = n;\r\n        p[fv] = n;\r\n        add(n, fu);\r\n        add(n, fv);\r\n    }\r\n}\r\nint main() {\r\n    while (~scanf(\"%d%d\", &amp;n, &amp;m)) {\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            scanf(\"%d%d%d\", &amp;g[i].u, &amp;g[i].v, &amp;g[i].w);\r\n            g[i].mark = false;\r\n        }\r\n        sort(g + 1, g + 1 + m);\r\n        initUset(n);\r\n        LL sum = 0;\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            int fx = uFind(g[i].u);\r\n            int fy = uFind(g[i].v);\r\n            if (fx != fy) {\r\n                sum += g[i].w;\r\n                g[i].mark = true;\r\n                p[fy] = fx;\r\n            }\r\n        }\r\n        for (int i = 1; i &lt;= n; i++)\r\n            query[i].clear();\r\n        scanf(\"%d\", &amp;size);\r\n        int u, v, w;\r\n        for (int i = 1; i &lt;= size; i++) {\r\n            scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);\r\n            qw[i] = w;\r\n            query[u].push_back(MP(v, i));\r\n            query[v].push_back(MP(u, i));\r\n        }\r\n        rebuild();\r\n        tarjan();\r\n        for (int i = 1; i &lt;= size; i++) {\r\n            LL ans = sum - val[lca[i]] + qw[i];\r\n            printf(LLS\"\\n\", min(ans, sum));\r\n        }\r\n    }\r\n}\r\n`\r\n其实，可以直接在dfs的回溯过程中将子节点的max求出来。这样简单多了。感叹一句：并查集真神奇！\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair&lt;int,int&gt;\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x &gt;::iterator\r\ndefine VI(x) vector&lt;x &gt;::iterator\r\ndefine MI(x,y) map&lt;x,y &gt;::iterator\r\ndefine SRI(x) set&lt;x &gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x &gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y &gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine clrQ(x) while(!x.empty())x.pop();\r\ndefine clrA(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\ndefine N 50005\r\ndefine M 100005\r\nint n, m;\r\nstruct Graph {\r\n    int u, v, w;\r\n    bool operator&lt;(Graph othr) const {\r\n        return w &lt; othr.w;\r\n    }\r\n} g[M];\r\nstruct Pair {\r\n    int x, y;\r\n    Pair(int x, int y) :\r\n            x(x), y(y) {\r\n    }\r\n    ;\r\n};\r\n//Edge Graph\r\nint head[N], pos;\r\nstruct Edge {\r\n    int v, w, nxt;\r\n} e[N &lt;&lt; 1];\r\nvoid initEdge() {\r\n    memset(head, -1, sizeof(head));\r\n    pos = 0;\r\n}\r\nvoid add(int u, int v, int w) {\r\n    e[pos].v = v;\r\n    e[pos].w = w;\r\n    e[pos].nxt = head[u];\r\n    head[u] = pos++;\r\n}\r\n//UnionSet\r\nint p[N];\r\nint pmax[N];\r\nvoid initUset() {\r\n    for (int i = 0; i &lt;= n; i++)\r\n        p[i] = i;\r\n}\r\nint uFind(int x) {\r\n    if (x != p[x]) {\r\n        int t = p[x];\r\n        p[x] = uFind(p[x]);\r\n        pmax[x] = max(pmax[x], pmax[t]);\r\n        return p[x];\r\n    }\r\n    return x;\r\n}\r\nvoid uMerge(int x, int y) { //y合并到x\r\n    int fx = uFind(x);\r\n    int fy = uFind(y);\r\n    if (fx != fy) {\r\n        p[fy] = fx;\r\n        pmax[fy] = max(pmax[fy], pmax[fx]);\r\n    }\r\n}\r\nint size;\r\nvector&lt;Pair&gt; query[N];\r\nvector&lt;Pair&gt; mark[N];\r\nint qw[N];\r\nbool vis[N];\r\nint lca[N];\r\nvoid dfs(int u, int fa) {\r\n    if (size == 0) return;\r\n    for (int i = head[u]; ~i; i = e[i].nxt) {\r\n        int v = e[i].v;\r\n        if (v == fa) continue;\r\n        dfs(v, u);\r\n        pmax[v] = max(pmax[v], e[i].w);\r\n        uMerge(u, v);\r\n    }\r\n    vis[u] = 1;\r\n    for (int i = 0; i &lt; (int) query[u].size(); i++) {\r\n        int v = queryu.x;\r\n        if (vis[v]) {\r\n            mark[uFind(v)].push_back(Pair(u, i));\r\n        }\r\n    }\r\n    if (!mark[u].empty()) {\r\n        for (VI(Pair)it=mark[u].begin();it!=mark[u].end();++it) {\r\n            int uu = it-&gt;x;\r\n            int vv = queryit-&gt;x.x;\r\n            int ss = queryit-&gt;x.y;\r\n            uFind(uu);\r\n            uFind(vv);\r\n            lca[ss] = max(pmax[uu], pmax[vv]);\r\n            size--;\r\n        }\r\n        mark[u].clear();\r\n    }\r\n}\r\nint findRoot() {\r\n    for (int i = 1; i &lt;= n; i++) {\r\n        if (!vis[i]) return i;\r\n    }\r\n    return assert(false), -1;\r\n}\r\nvoid tarjan() {\r\n    initUset();\r\n    clrA(vis, 0);\r\n    clrA(pmax, 0);\r\n    size = m;\r\n    dfs(findRoot(), -1);\r\n}\r\nint main() {\r\n    while (~scanf(\"%d%d\", &amp;n, &amp;m)) {\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            scanf(\"%d%d%d\", &amp;g[i].u, &amp;g[i].v, &amp;g[i].w);\r\n        }\r\n        sort(g + 1, g + 1 + m);\r\n        initUset();\r\n        initEdge();\r\n        LL sum = 0;\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            int fx = uFind(g[i].u);\r\n            int fy = uFind(g[i].v);\r\n            if (fx != fy) {\r\n                sum += g[i].w;\r\n                add(g[i].u, g[i].v, g[i].w);\r\n                add(g[i].v, g[i].u, g[i].w);\r\n                p[fy] = fx;\r\n            }\r\n        }\r\n        for (int i = 1; i &lt;= n; i++) {\r\n            query[i].clear();\r\n            mark[i].clear();\r\n        }\r\n        scanf(\"%d\", &amp;m);\r\n        int u, v, w;\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);\r\n            qw[i] = w;\r\n            query[u].push_back(Pair(v, i));\r\n            query[v].push_back(Pair(u, i));\r\n        }\r\n        tarjan();\r\n        for (int i = 1; i &lt;= m; i++) {\r\n            LL tmp = sum - lca[i] + qw[i];\r\n            printf(LLS\"\\n\", min(tmp, sum));\r\n        }\r\n    }\r\n}\r\n`",
        "tags": [
            "LCA",
            "图论",
            "tarjan"
        ]
    },
    {
        "uri": "/post/zjnu2082",
        "title": "内网2082 字母",
        "content": "\r\nDescription\r\n\r\n乐乐开始学习英文字母了，小C为他准备了很多字母牌，每张牌有一个英文字母。有天乐乐把所有的牌排成一行，这些字母竟然形成了一个回文串。小C想知道，乐乐在排字母的时候，有多少种情况，最后的字母形成回文串。\r\n\r\nInput\r\n\r\n输入一行，表示乐乐有哪些字母，均大写。\r\n\r\nOutput\r\n\r\n输出有多少种情况，排列的字母是一个回文串。\r\n!--more--\r\nSample Input\r\nAAAAB AABB CD\r\n\r\nSample Output\r\n\r\n1 2 0\r\n\r\nHint\r\n100%的数据，字母的个数不超过1000。\r\nbr/\r\n",
        "tags": []
    },
    {
        "uri": "/post/zjnu2085",
        "title": "内网 2085马农",
        "content": "\r\nDescription\r\n 在观看完战马检阅之后，来自大草原的两兄弟决心成为超级“马农”，专门饲养战马。\r\n\r\n兄弟两回到草原，将可以养马的区域，分为N*N的单位面积的正方形，并实地进行考察，归纳出了每个单位面积可以养马所获得的收益。接下来就要开始规划他们各自的马场了。\r\n\r\n首先，两人的马场都必须是矩形区域。同时，为了方便两人互相照应，也为了防止马匹互相走散，规定两个马场的矩形区域相邻，且只有一个交点。最后，互不认输的两人希望两个马场的收益相当，这样才不会影响他们兄弟的感情。\r\n\r\n现在，兄弟两找到你这位设计师，希望你给他们设计马场，问共有多少种设计方案。\r\n!--more--\r\nInput\r\n\r\n第一行一个整数N，表示整个草原的大小为N*N。\r\n\r\n接下来N行，每行N个整数A(i,j)，表示第i行第j列的单位草地的收成。（注意：收益可能是负数，养马也不是包赚的，马匹也可能出现生病死亡等意外。）\r\n\r\n1&lt;=N&lt;=50  \r\n-1000&lt;A(i,j)&lt;1000\r\n\r\nOutput\r\n\r\n\r\n 输出符合两人要求的草原分配方案数。\r\n\r\n\r\nSample Input\r\n\r\n3 1 2 3 4 5 6 7 8 9\r\n\r\nSample Output\r\n\r\n2\r\n\r\nHint\r\n\r\n\r\n\r\nSource\r\n\r\n\r\n2014宁波初中 T2\r\n\r\nbr/\r\n- -\r\n\r\n\r\n\r\n宁波镇海中学的罗方炜给我们组的一场比赛。\r\n\r\n此题主要靠技巧。枚举中心点，然后用数组hash。注意数组清空复杂度很大，每次清空必定超时。应该用一个栈来记录更改的地方，直接赋0.\r\n\r\n`C++\r\ninclude&lt;map&gt;\r\ninclude&lt;set&gt;\r\ninclude&lt;cmath&gt;\r\ninclude&lt;stack&gt;\r\ninclude&lt;queue&gt;\r\ninclude&lt;string&gt;\r\ninclude&lt;cstdio&gt;\r\ninclude&lt;vector&gt;\r\ninclude&lt;cctype&gt;\r\ninclude&lt;cassert&gt;\r\ninclude&lt;utility&gt;\r\ninclude&lt;numeric&gt;\r\ninclude&lt;cstring&gt;\r\ninclude&lt;iostream&gt;\r\ninclude&lt;algorithm&gt;\r\nusing namespace std;\r\ndefine pr pair\r\ndefine PR pair&lt;int,int&gt;\r\ndefine MP make_pair\r\ndefine SI(x) set&lt;x&gt;::iterator\r\ndefine VI(x) vector&lt;x&gt;::iterator\r\ndefine MI(x,y) map&lt;x,y&gt;::iterator\r\ndefine SRI(x) set&lt;x&gt;::reverse_iterator\r\ndefine VRI(x) vector&lt;x&gt;::reverse_iterator\r\ndefine MRI(x,y) map&lt;x,y&gt;::reverse_iterator\r\ndefine F first\r\ndefine S second\r\ndefine Sz(x) (int)x.size()\r\ndefine clrQ(x) while(!x.empty)x.pop();\r\ndefine clr(x,y) memset(x,y,sizeof(x));\r\nif defined (WIN32) || defined (WIN32) || defined (WIN32) || defined (WIN32_)\r\ndefine LL __int64\r\ndefine LLS \"%\" \"I\" \"6\" \"4\" \"d\"\r\ndefine LLU \"%\" \"I\" \"6\" \"4\" \"u\"\r\ndefine LLMAX _I64MAX\r\nelse\r\ndefine LL long long\r\ndefine LLS \"%\" \"l\" \"l\" \"d\"\r\ndefine LLU \"%\" \"l\" \"l\" \"u\"\r\ndefine LLMAX _I64MAX\r\nendif\r\nconst int inf = ~0u &gt;&gt; 1;\r\nconst LL lnf = ~0ull &gt;&gt; 1;\r\n/start/\r\ndefine N 55\r\ndefine M 2500000\r\nint fN,aN;\r\nint h[M&lt;&lt;1|1];\r\nint st[N*N],top;\r\nint n,m;\r\nint main(int argc, char **argv) {\r\n    while(~scanf(\"%d\",&amp;n)){\r\n        for (int i = 1; i &lt;= n; ++i) {\r\n            for (int j = 1; j &lt;= n; ++j) {\r\n                scanf(\"%d\",&amp;ai);\r\n                fi=fi-1+fi-fi-1+ai;\r\n            }\r\n        }\r\n        int res=top=0;\r\n        for (int x = 1; x &lt;= n; ++x) {\r\n            for (int y = 1; y &lt;= n; ++y) {\r\n                for (int i = 1; i &lt;= x; ++i) {\r\n                    for (int j = 1; j &lt;= y; ++j) {\r\n                        sttop++]=f[x-fx-fi-1+fi-1+M;\r\n                        h[st[top-1]]++;\r\n                    }\r\n                }\r\n                for (int i = x+1; i &lt;= n; ++i) {\r\n                    for (int j = y+1; j &lt;= n; ++j) {\r\n                        res+=hf[i-fi-fx+fx+M];\r\n                    }\r\n                }\r\n\r\n                while(top){\r\n                    h[st[--top]]=0;\r\n                }\r\n                for (int i = x; i &lt;= n; ++i) {\r\n                    for (int j = 1; j &lt;= y; ++j) {\r\n                        sttop++]=f[i-fx-1-fi+fx-1+M;\r\n                        h[st[top-1]]++;\r\n                    }\r\n                }\r\n                for (int i = 1; i &lt; x; ++i) {\r\n                    for (int j = y+1; j &lt;= n; ++j) {\r\n                        res+=hf[x-1-fx-1-fi-1+fi-1+M];\r\n                    }\r\n                }\r\n                while(top){\r\n                    h[st[--top]]=0;\r\n                }\r\n            }\r\n        }\r\n        printf(\"%d\\n\",res);\r\n    }\r\n}\r\n\r\n`",
        "tags": [
            "暴力"
        ]
    },
    {
        "uri": "/post/zoj-month-contest-d-determinant-and-matrix",
        "title": "ZOJ month contest D.Determinant and Matrix",
        "content": "\r\n\r\n* *\r\n\r\ncenter style=\"color: #000000;\"span style=\"color: green;\"Time Limit: /span2 Seconds      span style=\"color: green;\"Memory Limit: /span65536 KB/center\r\n\r\n* *\r\nDescription\r\nRecently, LBH is learning the curse linear algebra. Thus he is very interested in matrix and determinant now. In order to practice his ability of solving the problem of linear algebra, he just invent some problems by himself. Once the problems was create, he would solve it immediately. However, he meet a problem that was so hard that he couldn't work out even though racked his brains. The problem was described as follow:\r\n\r\nTo a integer martix Msubnn/sub(asubij/sub), we define two function add(Msubnn/sub(asubij/sub))=Msubnn/sub(asubij/sub + 1) and sub(Msubnn/sub(asubij/sub))=Msubnn/sub(asubij/sub - 1) which were exactly like this:\r\n!--more--\r\ndiv style=\"color: 000000;\"/div\r\ndiv style=\"color: #000000;\"/div\r\n\r\nAccording to the martix Msubnn/sub(asubij/sub), we can permutate it and get a full permutation set Perm(Msubnn/sub(asubij/sub)) = {Msubnn/sub(asubIsubi/subJsubj/sub/sub)| I and J is a permutation of 1..n }, (Perm(M) is a set, each matrix in Perm(M) is unique). For example:\r\n\r\ndiv style=\"color: #000000;\"/div\r\n\r\nThe problem is to get the result of a fomula about an integer matrix Msubnn/sub:\r\n\r\ndiv style=\"color: #000000;\"/div\r\nspan style=\"color: #000000;\"in which the det(M) meaned to cacluate the determinant of M./span\r\n\r\nInput\r\n\r\nThere are several test cases.\r\n\r\nThe first line contains an integer varT/var(varT/var ≤ 100) . Then varT/var test cases follow.\r\n\r\nIn each test case, the first line contains one integer varn/var(0&lt; varn/var≤ 10). The number means the giving matrix's size is varn×n/var\r\n\r\nThen there are varn/var lines followed, each line contains varn/var integers varasubij/sub/var(-10≤ varasubij/sub/var≤ 10), in the position row vari/var, colum varj/var, it represents the number varasubij/sub./var\r\n\r\n Output\r\n\r\nFor each test case, since the result may be very large, output one line with the result modulo 2sup30/sup.\r\n\r\nSample Input\r\n`\r\n1\r\n2\r\n1 1\r\n1 2\r\n`\r\n Sample Output\r\n\r\n`\r\n2\r\n`\r\n\r\nspan style=\"color: #000000;\"Author: /spanLIN, Binghui\r\nspan style=\"color: #000000;\"Source: /spanZOJ Monthly, August 2014\r\n\r\nbr/\r\n\r\n- -\r\n\r\n\r\n这道题全场现场只A了一个人。今天我们比赛的时候我A了，挺爽的。\r\n`Java\r\nimport java.util.Scanner;\r\nimport java.math.*;\r\npublic class Main {\r\n\tstatic long fact[]=new long[15];\r\n\tstatic long kind;\r\n\tstatic int A=new int10;\r\n\tstatic final BigInteger MOD=BigInteger.valueOf(1&lt;&lt;30);\r\n\tstatic void getKind(int n){\r\n\t\tboolean mark[]=new boolean[10];\r\n\t\tfor(int i,j,k,r=0;r&lt;2;r++){\r\n\t\t\tfor (i = 0; i &lt; n; ++ i) mark[i] = false;\r\n\t\t\tfor (i = 0; i &lt; n; ++ i) {\r\n\t\t\t\tif (mark[i]) continue;\r\n\t\t\t\tint cnt = 0;\r\n\t\t\t\tfor (j = i; j &lt; n; ++ j) {\r\n\t\t\t\t\tfor (k = 0; k &lt; n; ++ k) {\r\n\t\t\t\t\t\tif (r==1&amp;&amp;Ak != Ak)break;\r\n\t\t\t\t\t\tif(r==0&amp;&amp;Ai != Aj)break;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (k == n) {\r\n\t\t\t\t\t\t++ cnt;\r\n\t\t\t\t\t\tmark[j] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tkind /= fact[cnt];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tpublic static void main(String[] args){\r\n\t\tScanner cin=new Scanner(System.in);\r\n\t\tint n,T=cin.nextInt();\r\n\t\tfact[0]=1;\r\n\t\tfor(int i=1;i&lt;=10;i++)fact[i]=fact[i-1]*i;\r\n\t\twhile(T--&gt;0){\r\n\t\t\tn=cin.nextInt();\r\n\t\t\tfor(int i=0;i&lt;n;i++){\r\n\t\t\t\tfor(int j=0;j&lt;n;j++){\r\n\t\t\t\t\tAi=cin.nextInt();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlong res=0;\r\n\t\t\tMatrix matrix=new Matrix(n);\r\n\t\t\tkind=fact[n]*fact[n];\r\n\t\t\tgetKind(n);\r\n\t\t\tif(kind%2==1){\r\n\t\t\t\tmatrix.valueOf(A, 0);\r\n\t\t\t\tres=res ^(matrix.Det().mod(MOD).longValue());\r\n\t\t\t}\r\n\t\t\tmatrix.valueOf(A, 1);\r\n\t\t\tres=res^(matrix.Det().mod(MOD).longValue());\r\n\t\t\tmatrix.valueOf(A, -1);\r\n\t\t\tres=res^(matrix.Det().mod(MOD).longValue());\r\n\t\t\tSystem.out.println(res);\r\n\t\t}\r\n\t\tcin.close();\r\n\t}\r\n}\r\nclass Matrix{\r\n\tBigInteger M=new BigInteger10;\r\n\tBigInteger ZERO,ONE;\r\n\tint n;\r\n\tMatrix(int n){\r\n\t\tthis.n=n;\r\n\t\tZERO=BigInteger.ZERO;\r\n\t\tONE=BigInteger.ONE;\r\n\t}\r\n\tvoid valueOf(int A,int d){\r\n\t\tfor(int i=0;i&lt;n;i++){\r\n\t\t\tfor(int j=0;j&lt;n;j++){\r\n\t\t\t\tMi=BigInteger.valueOf(Ai+d);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tBigInteger Det(){\r\n\t\tBigInteger tmp, res = ONE, div = ONE;\r\n\t\tint i, j, k;\r\n\t\tfor (i = 0; i &lt; n; ++ i) {\r\n\t\t\tfor (j = i; j &lt; n; ++ j) {\r\n\t\t\t\tif (!Mj.equals(ZERO)) break;\r\n\t\t\t}\r\n\t\t\tif (j == n) return ZERO;\r\n\t\t\tif (j != i) {\r\n\t\t\t\t//res = res.negate();\r\n\t\t\t\tfor (k = 0; k &lt; n; ++ k) {\r\n\t\t\t\t    tmp = Mj;\r\n\t\t\t\t\tMj = Mi;\r\n\t\t\t\t\tMi = tmp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tres = res.multiply(Mi);\r\n\t\t\tfor (j = i + 1; j &lt; n; ++ j) {\r\n\t\t\t\tif (Mj.equals(ZERO)) continue;\r\n\t\t\t\tdiv = div.multiply(Mi);\r\n\t\t\t\tfor (k = i + 1; k &lt; n; ++ k) {\r\n\t\t\t\t\tMj = Mj.multiply(Mi).subtract(Mi.multiply(Mj));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tres = res.divide(div);\r\n\t\tif (res.compareTo(ZERO) &lt; 0) res = res.negate();\r\n\t\treturn res;\r\n\t}\r\n}\r\n`\r\n/pre",
        "tags": []
    }
]